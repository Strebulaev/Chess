--- Файл: D:\Chess\src\index.html ---

<!-- Файл: src/index.html -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>DnDchess</title>
  <base href="/">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
</head>
<body>
  <app-root></app-root>
</body>
</html>

--- Файл: D:\Chess\src\main.ts ---

import { bootstrapApplication } from '@angular/platform-browser';
import { appConfig } from './app/app.config';
import { AppComponent } from './app/app.component';

bootstrapApplication(AppComponent, appConfig)
  .catch((err) => console.error(err));

--- Файл: D:\Chess\src\styles.scss ---

/* Общие стили для всех режимов */
:root {
  --primary: #3a529c;
  --primary-light: #4a6bda;
  --text: #2d3748;
  --text-light: #718096;
  --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

/* Базовые стили */
body {
  font-family: 'Inter', system-ui, sans-serif;
  background: #121212;
  color: white;
  margin: 0;
  line-height: 1.5;
}

/* Шахматная доска - общие стили */
.chessboard {
  position: relative;
  border-radius: 8px;
  overflow: hidden;
  box-shadow: 0 10px 30px rgba(0,0,0,0.5);
  margin: 0 auto;
  
  .row {
    display: flex;
  }

  .cell {
    width: 60px;
    height: 60px;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    cursor: pointer;
    transition: var(--transition);

    span {
      font-size: 40px;
      user-select: none;
      pointer-events: none;
      z-index: 2;
      transition: var(--transition);
    }

    &.selected {
      &::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 40px;
        height: 40px;
        border-radius: 50%;
        box-shadow: 0 0 15px currentColor;
        z-index: -1;
      }
    }

    .move-dot {
      position: absolute;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      z-index: 1;
    }
  }
}

/* Классический режим */
.chessboard.classic-mode {
  border: 12px solid #5D4037;
  background: #5D4037;

  .cell {
    &:nth-child(odd) { background: #f0d9b5; }
    &:nth-child(even) { background: #b58863; }
    
    &.selected::after { background: rgba(52, 152, 219, 0.5); }
    
    .move-dot {
      background: rgba(46, 204, 113, 0.8);
      box-shadow: 0 0 10px rgba(46, 204, 113, 0.8);
    }
  }

  .row:nth-child(odd) .cell {
    &:nth-child(odd) { background: #b58863; }
    &:nth-child(even) { background: #f0d9b5; }
  }

  span.white {
    color: white;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
  }

  span.black {
    color: #222;
    text-shadow: 1px 1px 2px rgba(255,255,255,0.3);
  }
}

/* D&D режим */
.chessboard.dnd-mode {
  border: 12px solid #6C3483;
  background: #2C3E50;

  .cell {
    background: rgba(44, 62, 80, 0.7) !important;
    border: 1px solid rgba(255,255,255,0.05);
    
    &:nth-child(even) { background: rgba(108, 52, 131, 0.5) !important; }
    
    &.selected::after { 
      background: rgba(155, 89, 182, 0.5);
      box-shadow: 0 0 15px rgba(155, 89, 182, 0.7);
    }
    
    .move-dot {
      background: rgba(241, 196, 15, 0.8);
      box-shadow: 0 0 15px rgba(241, 196, 15, 0.8);
    }
  }

  .row:nth-child(odd) .cell {
    &:nth-child(odd) { background: rgba(108, 52, 131, 0.5) !important; }
    &:nth-child(even) { background: rgba(44, 62, 80, 0.7) !important; }
  }

  span.white {
    color: #f1c40f;
    text-shadow: 0 0 10px #f1c40f;
    animation: whitePulse 3s infinite alternate;
  }

  span.black {
    color: #e74c3c;
    text-shadow: 0 0 10px #c0392b;
    animation: blackPulse 3s infinite alternate;
  }
}

/* 5D режим */
.chessboard.five-d-mode {
  border: 12px solid #3498DB;
  background: #0F2027;

  .cell {
    background: rgba(25, 42, 86, 0.7) !important;
    border: 1px solid rgba(255,255,255,0.1);
    
    &:nth-child(even) { background: rgba(52, 152, 219, 0.5) !important; }
    
    &.selected::after { 
      background: rgba(52, 152, 219, 0.5);
      box-shadow: 0 0 15px rgba(52, 152, 219, 0.7);
    }
    
    .move-dot {
      background: rgba(46, 204, 113, 0.8);
      box-shadow: 0 0 15px rgba(46, 204, 113, 0.8);
    }
  }

  .row:nth-child(odd) .cell {
    &:nth-child(odd) { background: rgba(52, 152, 219, 0.5) !important; }
    &:nth-child(even) { background: rgba(25, 42, 86, 0.7) !important; }
  }

  span.white {
    color: #2ecc71;
    text-shadow: 0 0 10px #2ecc71;
    animation: whiteGlow 3s infinite alternate;
  }

  span.black {
    color: #9b59b6;
    text-shadow: 0 0 10px #8e44ad;
    animation: blackGlow 3s infinite alternate;
  }
}

/* Анимации */
@keyframes whitePulse {
  0% { filter: drop-shadow(0 0 5px #f1c40f); }
  100% { filter: drop-shadow(0 0 15px #f39c12); }
}

@keyframes blackPulse {
  0% { filter: drop-shadow(0 0 5px #e74c3c); }
  100% { filter: drop-shadow(0 0 15px #c0392b); }
}

@keyframes whiteGlow {
  0% { filter: drop-shadow(0 0 5px #2ecc71); }
  100% { filter: drop-shadow(0 0 15px #27ae60); }
}

@keyframes blackGlow {
  0% { filter: drop-shadow(0 0 5px #9b59b6); }
  100% { filter: drop-shadow(0 0 15px #8e44ad); }
}

/* Меню */
.chess-menu {
  display: flex;
  justify-content: center;
  gap: 12px;
  padding: 1rem;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 12px;
  margin-bottom: 2rem;

  .menu-item {
    width: 56px;
    height: 56px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 12px;
    background: transparent;
    color: var(--text-light);
    transition: var(--transition);
    position: relative;
    cursor: pointer;
    font-size: 24px;

    &:hover {
      background: rgba(74, 107, 218, 0.1);
      color: var(--primary);
      transform: translateY(-2px);
    }

    &.active {
      background: rgba(74, 107, 218, 0.2);
      color: var(--primary);
    }
  }
}

/* Лобби */
.lobby-container {
  max-width: 500px;
  margin: 0 auto;
  background: rgba(30, 30, 30, 0.8);
  backdrop-filter: blur(10px);
  border-radius: 16px;
  padding: 2rem;
  box-shadow: 0 10px 30px rgba(0,0,0,0.3);
  text-align: center;

  h2 {
    color: white;
    margin-bottom: 2rem;
  }

  button {
    background: var(--primary);
    color: white;
    border: none;
    padding: 0.75rem 1.5rem;
    border-radius: 8px;
    cursor: pointer;
    transition: var(--transition);
    font-size: 1rem;
    margin-top: 1rem;

    &:hover {
      background: var(--primary-light);
      transform: translateY(-2px);
    }

    &:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }
  }
}

/* Адаптивность */
@media (max-width: 768px) {
  .chessboard .cell {
    width: 40px;
    height: 40px;
    
    span {
      font-size: 30px;
    }
  }
  
  .lobby-container {
    padding: 1.5rem;
  }
}

--- Файл: D:\Chess\src\app\app.component.html ---

<div class="app-container">
  <header class="app-header">
    <div class="header-content">
      <nav class="chess-menu">
        <a *ngFor="let mode of chessModes" 
           [routerLink]="['/chess', mode.path]" 
           class="menu-item"
           [class.active]="isActiveMode(mode.path)"
           [attr.title]="mode.title">
          <span class="menu-icon">{{mode.icon}}</span>
          <span class="menu-tooltip">
            <span class="tooltip-title">{{mode.title}}</span>
            <span class="tooltip-description">{{mode.description}}</span>
          </span>
        </a>
      </nav>
    </div>
  </header>

  <main class="main-content">
    <router-outlet></router-outlet>
  </main>
</div>

--- Файл: D:\Chess\src\app\app.component.scss ---

/* Глобальные переменные */
:root {
  --primary: #3a529c;
  --primary-light: #4a6bda;
  --text: #2d3748;
  --text-light: #718096;
  --bg: #f8fafc;
  --menu-bg: rgba(255, 255, 255, 0.96);
  --border: rgba(0, 0, 0, 0.08);
  --shadow: 0 4px 24px rgba(0, 0, 0, 0.08);
  --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

/* Базовые стили */
body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
  background: var(--bg);
  color: var(--text);
  margin: 0;
  line-height: 1.5;
}

.app-container {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

/* Шапка - стеклянный эффект */
.app-header {
  position: sticky;
  top: 0;
  z-index: 50;
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  background: var(--menu-bg);
  border-bottom: 1px solid var(--border);
  box-shadow: var(--shadow);
  height: 90px;
  display: flex;
  align-items: center;
  padding: 0 24px;

  .header-content {
    width: 100%;
    max-width: 1400px;
    margin: 0 auto;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
}

/* Заголовок */
.header-title {
  font-size: 1.5rem;
  font-weight: 700;
  color: var(--primary);
  margin: 0;
  padding: 0 24px 0 0;
  position: relative;
  display: flex;
  align-items: center;
  height: 100%;

  &::after {
    content: '';
    position: absolute;
    right: 0;
    top: 20%;
    height: 60%;
    width: 1px;
    background: linear-gradient(to bottom, 
      transparent 0%, 
      var(--border) 20%, 
      var(--border) 80%, 
      transparent 100%);
  }

  span {
    background: linear-gradient(90deg, var(--primary), var(--primary-light));
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
  }
}

/* Меню иконок */
.chess-menu {
  display: flex;
  justify-content: center; // Добавлено центрирование по горизонтали
  align-items: center;    // Добавлено центрирование по вертикали
  gap: 8px;
  height: 100%;
  width: 100%;           // Добавлено для правильного центрирования
  margin: 0 auto;        // Добавлено для дополнительного центрирования
  padding: 0 20px;

  .menu-item {
    text-decoration: none;
    width: 56px;
    height: 56px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 16px;
    background: transparent;
    color: var(--text-light);
    transition: var(--transition);
    position: relative;
    cursor: pointer;

    &:hover {
      background: rgba(74, 107, 218, 0.08);
      color: var(--primary);
      transform: translateY(-2px);

      .menu-tooltip {
        opacity: 1;
        visibility: visible;
        transform: translateY(0);
      }
    }

    &.active {
      background: rgba(74, 107, 218, 0.12);
      color: var(--primary);
    }

    .menu-icon {
      font-size: 24px;
      transition: var(--transition);
    }

    .menu-tooltip {
      position: absolute;
      top: calc(100% + 12px);
      right: 0;
      background: white;
      padding: 12px 16px;
      border-radius: 12px;
      box-shadow: var(--shadow);
      min-width: 220px;
      opacity: 0;
      visibility: hidden;
      transform: translateY(8px);
      transition: var(--transition);
      z-index: 10;
      text-align: left;
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      background: rgba(255, 255, 255, 0.88);
      border: 1px solid var(--border);

      &::before {
        content: '';
        position: absolute;
        bottom: 100%;
        right: 20px;
        border-width: 8px;
        border-style: solid;
        border-color: transparent transparent rgba(255, 255, 255, 0.88) transparent;
        filter: drop-shadow(0 -1px 1px rgba(0, 0, 0, 0.05));
      }

      .tooltip-title {
        display: block;
        font-weight: 600;
        color: var(--primary);
        margin-bottom: 4px;
        font-size: 15px;
      }

      .tooltip-description {
        display: block;
        font-size: 14px;
        color: var(--text-light);
        line-height: 1.4;
      }
    }
  }
}

/* Основное содержимое */
.main-content {
  flex: 1;
  padding: 32px;
  max-width: 1400px;
  margin: 0 auto;
  width: 100%;
}

/* Адаптивность */
@media (max-width: 768px) {
  .app-header {
    height: 64px;
    padding: 0 16px;

    .header-title {
      font-size: 1.25rem;
      padding-right: 16px;
    }
  }

  .chess-menu .menu-item {
    width: 48px;
    height: 48px;
    border-radius: 12px;
  }

  .main-content {
    padding: 24px 16px;
  }
}


--- Файл: D:\Chess\src\app\app.component.ts ---

import { CommonModule } from '@angular/common';
import { Component } from '@angular/core';
import { Router, RouterLink, RouterOutlet } from '@angular/router';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.scss'],
  imports: [RouterOutlet, CommonModule, RouterLink],
  standalone: true
})
export class AppComponent {
  constructor(private router: Router) {}
  
  chessModes = [
    {
      path: 'classic',
      title: 'Classic Chess',
      description: 'Traditional 8x8 chess with standard rules',
      icon: '♔'
    },
    {
      path: '5d',
      title: '5D Chess',
      description: 'Multidimensional time-travel chess',
      icon: '🌀'
    },
    {
      path: 'dnd',
      title: 'D&D Chess',
      description: 'Fantasy RPG chess with special abilities',
      icon: '⚔️'
    }
  ];

  isActiveMode(path: string): boolean {
    return this.router.url.includes(`/chess/${path}`);
  }

  getCurrentModeTitle(): string {
    const url = this.router.url;
    if (url.includes('/chess/classic')) return 'Classic Chess';
    if (url.includes('/chess/5d')) return '5D Chess';
    if (url.includes('/chess/dnd')) return 'D&D Chess';
    return 'Chess';
  }
}

--- Файл: D:\Chess\src\app\app.config.ts ---

import { ApplicationConfig } from '@angular/core';
import { provideRouter } from '@angular/router';
import { provideFirebaseApp, initializeApp } from '@angular/fire/app';
import { provideDatabase, getDatabase } from '@angular/fire/database';
import { routes } from './app.routes';
import { provideAnimations } from '@angular/platform-browser/animations';
import { provideHttpClient } from '@angular/common/http';
import { provideZoneChangeDetection } from '@angular/core';
import { DatePipe } from '@angular/common';

const firebaseConfig = {
  apiKey: "AIzaSyBj1T7DGrGLTfapIWb2wXKdPC9FbbOeluo",
  authDomain: "dndchess-dbcbe.firebaseapp.com",
  databaseURL: "https://dndchess-dbcbe-default-rtdb.firebaseio.com",
  projectId: "dndchess-dbcbe",
  storageBucket: "dndchess-dbcbe.appspot.com",
  messagingSenderId: "455536765703",
  appId: "1:455536765703:web:2b2e60048e6abeffdd33a2",
};

export const appConfig: ApplicationConfig = {
  providers: [
    provideRouter(routes),
    provideAnimations(),
    provideHttpClient(),
    provideZoneChangeDetection({ eventCoalescing: true }),
    provideFirebaseApp(() => initializeApp(firebaseConfig)),
    provideDatabase(() => getDatabase()),
    DatePipe
  ],
};

--- Файл: D:\Chess\src\app\app.routes.ts ---

import { Routes } from '@angular/router';

export const routes: Routes = [
  { 
    path: 'chess',
    children: [
      { 
        path: 'classic',
        loadChildren: () => import('./features/classic-chess/classic-chess.module')
          .then(m => m.ClassicChessModule)
      },
      { 
        path: '5d',
        loadChildren: () => import('./features/five-d-chess/five-d-chess.module')
          .then(m => m.FiveDChessModule)
      },
      { 
        path: 'dnd',
        loadChildren: () => import('./features/dnd-chess/dnd-chess.module')
          .then(m => m.DndChessModule)
      },
      { 
        path: 'game/:id',
        loadComponent: () => import('./shared/ui/game-wrapper/game-wrapper.component')
          .then(m => m.GameWrapperComponent)
      },
      { 
        path: '',
        redirectTo: 'classic',
        pathMatch: 'full'
      }
    ]
  },
  { 
    path: '',
    redirectTo: 'chess/classic',
    pathMatch: 'full'
  },
  { 
    path: '**',
    redirectTo: 'chess/classic'
  }
];

--- Файл: D:\Chess\src\app\features\classic-chess\classic-chess.module.ts ---

import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterModule } from '@angular/router';

@NgModule({
  imports: [
    CommonModule,
    RouterModule.forChild([
      { 
        path: '', 
        loadComponent: () => import('./components/lobby/lobby.component')
          .then(m => m.LobbyComponent) 
      },
      { 
        path: 'game/:id', 
        loadComponent: () => import('./components/game/classic-game.component')
          .then(m => m.ClassicGameComponent)
      }
    ])
  ]
})
export class ClassicChessModule { }

--- Файл: D:\Chess\src\app\features\classic-chess\classic-chess.routes.ts ---



--- Файл: D:\Chess\src\app\features\classic-chess\components\game\classic-game.component.html ---

<div class="chessboard-container" [class.classic-mode]="chessType === 'classic'"
                                [class.dnd-mode]="chessType === 'dnd'"
                                [class.five-d-mode]="chessType === '5d'">
  <div class="game-info">
    Ход: {{ gameService.getState().currentPlayer === 'white' ? 'Белые' : 'Чёрные' }}
  </div>
  <app-chessboard [state]="gameService.getState()"></app-chessboard>
  <div class="game-id">ID: {{ gameId }}</div>
  <div class="chat-panel-container">
    <app-chat [gameId]="gameId"></app-chat>
  </div>
</div>

--- Файл: D:\Chess\src\app\features\classic-chess\components\game\classic-game.component.scss ---

.game {
  background-color: white;
  border-radius: 8px;
  padding: 2rem;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
  width: 100%;
  max-width: 800px;
  text-align: center;

  h1 {
    color: #333;
    margin-bottom: 1rem;
  }

  p {
    font-size: 1.2rem;
    margin-bottom: 2rem;
    color: #555;
  }
}
.game-screen {
    display: flex;
    min-height: 100vh;
  }
  
  .main-content {
    flex-grow: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 20px;
  }
  
  .side-panel-container {
    width: 280px;
    padding: 20px;
  }
  
  .chat-panel-container {
    width: 300px;
    border-left: 1px solid rgba(255, 255, 255, 0.1);
  }
  
  @media (max-width: 1200px) {
    .side-panel-container,
    .chat-panel-container {
      width: 250px;
    }
  }
  
  @media (max-width: 992px) {
    .game-screen {
      flex-direction: column;
    }
    
    .side-panel-container,
    .chat-panel-container {
      width: 100%;
      max-width: 500px;
      margin: 0 auto;
    }
    
    .chat-panel-container {
      border-left: none;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }
  }

--- Файл: D:\Chess\src\app\features\classic-chess\components\game\classic-game.component.ts ---

import { Component, OnInit, OnDestroy } from '@angular/core';
import { ActivatedRoute, Router } from '@angular/router';
import { GameService } from '../../../../shared/chess-core/services/game.service';
import { MultiplayerService } from '../../../../shared/chess-core/services/multiplayer.service';
import { ChessboardComponent } from '../../../../shared/ui/chessboard/chessboard.component';
import { CommonModule } from '@angular/common';
import { createInitialGameState } from '../../../../shared/chess-core/models/game-state.model';
import { ChatComponent } from "../../../../shared/ui/chat/chat.component";
import { ClassicGameService } from '../../services/classic-game.service';

@Component({
  selector: 'app-classic-game',
  templateUrl: './classic-game.component.html',
  styleUrls: ['./classic-game.component.scss'],
  standalone: true,
  imports: [ChessboardComponent, CommonModule, ChatComponent]
})
export class ClassicGameComponent implements OnInit, OnDestroy {
  gameId: string = '';
  chessType: string = 'classic';

  constructor(
    private route: ActivatedRoute,
    private router: Router,
    public gameService: GameService,
    private multiplayer: MultiplayerService
  ) {}

  ngOnInit(): void {
    this.gameId = this.route.snapshot.params['id'];
    
    // Извлекаем тип игры из ID (первые символы до дефиса)
    const gameType = this.gameId.split('-')[0] as 'classic' | '5d' | 'dnd';
    
    if (!['classic', '5d', 'dnd'].includes(gameType)) {
        this.router.navigate(['/chess/classic']);
        return;
    }
    
    this.chessType = gameType;
    
    // Инициализируем состояние игры с правильным типом
    this.gameService.setState(createInitialGameState(gameType));
    
    if (this.gameId) {
        this.multiplayer.joinGame(this.gameId);
    }
  }

  ngOnDestroy(): void {
    this.multiplayer.ngOnDestroy();
  }

  onLeaveGame(): void {
    this.router.navigate(['/chess', this.chessType]);
  }
}

--- Файл: D:\Chess\src\app\features\classic-chess\components\lobby\lobby.component.html ---

<!-- Файл: src/app/components/lobby/lobby.component.html -->
<div class="lobby-container">
  <div class="decorative-corner decorative-corner-tl"></div>
  <div class="decorative-corner decorative-corner-br"></div>
  
  <div class="mode-indicator" *ngIf="currentMode">
    <div class="mode-icon">{{currentMode.icon}}</div>
    <div class="mode-title">{{currentMode.title}}</div>
  </div>

  <h2>Create or Join Game</h2>
  
  <div class="game-options">
    <div class="option-card">
      <h3>Create New Game</h3>
      <button (click)="createGame()" [disabled]="isLoading">
        {{ isLoading ? 'Creating...' : 'Create Game' }}
      </button>
    </div>

    <div class="option-card">
      <h3>Join Existing Game</h3>
      <div class="input-group">
        <input [(ngModel)]="gameId" placeholder="Enter Game ID">
        <button (click)="joinGame()" [disabled]="isLoading || !gameId">
          {{ isLoading ? 'Joining...' : 'Join Game' }}
        </button>
      </div>
    </div>
  </div>

  <div *ngIf="errorMessage" class="error-message">
    {{ errorMessage }}
  </div>
</div>

--- Файл: D:\Chess\src\app\features\classic-chess\components\lobby\lobby.component.scss ---

/* Файл: src/app/components/lobby/lobby.component.scss */

.lobby-container {
  max-width: 800px;
  margin: 2rem auto;
  background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
  border-radius: 16px;
  padding: 2.5rem;
  box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
  text-align: center;
  border: 1px solid rgba(255, 255, 255, 0.1);
  position: relative;
  overflow: hidden;
  
  &::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 4px;
    background: linear-gradient(90deg, #00dbde 0%, #fc00ff 100%);
  }

  h2 {
    color: #fff;
    margin-bottom: 2rem;
    font-size: 2.2rem;
    font-weight: 700;
    text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    position: relative;
    z-index: 2;
  }

  .game-options {
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
    margin-bottom: 2rem;
  }
  .mode-indicator {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 12px;
    margin-bottom: 2rem;
    padding: 1rem;
    background: rgba(74, 107, 218, 0.1);
    border-radius: 12px;
    border: 1px solid rgba(74, 107, 218, 0.2);
    animation: fadeIn 0.3s ease-out;

    .mode-icon {
      font-size: 2rem;
      color: var(--primary);
    }

    .mode-title {
      font-size: 1.25rem;
      font-weight: 600;
      color: var(--primary);
    }
  }

  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(-10px); }
    to { opacity: 1; transform: translateY(0); }
  }
  .option-card {
    background: rgb(0, 0, 0);
    border-radius: var(--border-radius);
    padding: 1.5rem;
    box-shadow: 0 5px 15px rgba(0,0,0,0.05);
    border: 1px solid rgba(0,0,0,0.05);
    transition: var(--transition);

    &:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 25px rgba(0,0,0,0.1);
    }

    h3 {
      color: var(--primary-color);
      margin-bottom: 1rem;
    }

    .input-group {
      display: flex;
      gap: 0.5rem;
      margin-top: 1rem;

      input {
        flex: 1;
        padding: 0.75rem 1rem;
        border: 1px solid #ddd;
        border-radius: var(--border-radius);
        font-size: 1rem;
        transition: var(--transition);

        &:focus {
          outline: none;
          border-color: var(--secondary-color);
          box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
        }
      }

      button {
        padding: 0.75rem 1.5rem;
        background: var(--secondary-color);
        color: white;
        border: none;
        border-radius: var(--border-radius);
        cursor: pointer;
        font-size: 1rem;
        transition: var(--transition);

        &:hover {
          background: adjust-color(#3498db, $lightness: -10%);
          transform: translateY(-2px);
        }

        &:disabled {
          background: #bdc3c7;
          cursor: not-allowed;
          transform: none;
        }
      }
    }
  }

  .error-message {
    color: var(--danger-color);
    margin-top: 1rem;
    padding: 0.75rem;
    background: rgba(231, 76, 60, 0.1);
    border-radius: var(--border-radius);
  }
}

@media (max-width: 768px) {
  .lobby-container {
    padding: 1.5rem;

    h2 {
      font-size: 1.5rem;
    }

    .option-card {
      padding: 1rem;

      .input-group {
        flex-direction: column;

        button {
          width: 100%;
        }
      }
    }
  }
}
.mode-indicator {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 12px;
  margin-bottom: 2rem;
  padding: 1rem;
  background: rgba(74, 107, 218, 0.1);
  border-radius: 12px;
  border: 1px solid rgba(74, 107, 218, 0.2);
  animation: fadeIn 0.3s ease-out;

  .mode-icon {
    font-size: 2rem;
    color: var(--primary);
  }

  .mode-title {
    font-size: 1.25rem;
    font-weight: 600;
    color: var(--primary);
  }
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(-10px); }
  to { opacity: 1; transform: translateY(0); }
}
/* Файл: src/app/components/lobby/lobby.component.scss */

.lobby-container {
  max-width: 800px;
  margin: 2rem auto;
  background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
  border-radius: 16px;
  padding: 2.5rem;
  box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
  text-align: center;
  border: 1px solid rgba(255, 255, 255, 0.1);
  position: relative;
  overflow: hidden;
  
  &::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 4px;
    background: linear-gradient(90deg, #00dbde 0%, #fc00ff 100%);
  }

  h2 {
    color: #fff;
    margin-bottom: 2rem;
    font-size: 2.2rem;
    font-weight: 700;
    text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    position: relative;
    z-index: 2;
  }
}

.mode-indicator {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 16px;
  margin-bottom: 2.5rem;
  padding: 1.25rem;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 12px;
  border: 1px solid rgba(255, 255, 255, 0.1);
  backdrop-filter: blur(10px);
  animation: fadeIn 0.5s ease-out;
  position: relative;
  z-index: 2;

  .mode-icon {
    font-size: 2.5rem;
    color: #fff;
    text-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
  }

  .mode-title {
    font-size: 1.5rem;
    font-weight: 600;
    color: #fff;
    letter-spacing: 1px;
  }
}

.game-options {
  display: grid;
  grid-template-columns: 1fr;
  gap: 2rem;
  margin-bottom: 2rem;
}

.option-card {
  background: rgba(255, 255, 255, 0.05);
  border-radius: 14px;
  padding: 2rem;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
  border: 1px solid rgba(255, 255, 255, 0.1);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  backdrop-filter: blur(10px);
  position: relative;
  overflow: hidden;
  
  &:hover {
    transform: translateY(-5px);
    box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3);
    border-color: rgba(255, 255, 255, 0.2);
  }

  &::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: radial-gradient(circle at 20% 50%, rgba(100, 115, 255, 0.1) 0%, transparent 50%);
    z-index: -1;
  }

  h3 {
    color: #fff;
    margin-bottom: 1.5rem;
    font-size: 1.5rem;
    font-weight: 600;
  }

  button {
    padding: 0.9rem 2rem;
    background: linear-gradient(90deg, #00dbde 0%, #fc00ff 100%);
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 1.1rem;
    font-weight: 600;
    transition: all 0.3s ease;
    box-shadow: 0 4px 15px rgba(0, 219, 222, 0.3);
    position: relative;
    overflow: hidden;
    
    &:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(0, 219, 222, 0.4);
    }
    
    &:active:not(:disabled) {
      transform: translateY(0);
    }
    
    &:disabled {
      background: linear-gradient(90deg, #6c757d 0%, #495057 100%);
      cursor: not-allowed;
      opacity: 0.7;
    }
    
    &::after {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: all 0.5s ease;
    }
    
    &:hover:not(:disabled)::after {
      left: 100%;
    }
  }
}

.input-group {
  display: flex;
  gap: 1rem;
  margin-top: 1.5rem;
  
  input {
    flex: 1;
    padding: 0.9rem 1.5rem;
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 8px;
    font-size: 1rem;
    color: #fff;
    transition: all 0.3s ease;
    
    &::placeholder {
      color: rgba(255, 255, 255, 0.5);
    }
    
    &:focus {
      outline: none;
      border-color: #00dbde;
      box-shadow: 0 0 0 3px rgba(0, 219, 222, 0.2);
      background: rgba(255, 255, 255, 0.15);
    }
  }
}

.error-message {
  color: #ff6b6b;
  margin-top: 1.5rem;
  padding: 1rem;
  background: rgba(255, 107, 107, 0.1);
  border-radius: 8px;
  border: 1px solid rgba(255, 107, 107, 0.3);
  animation: shake 0.5s ease;
}

/* Анимации */
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(-20px); }
  to { opacity: 1; transform: translateY(0); }
}

@keyframes shake {
  0%, 100% { transform: translateX(0); }
  20%, 60% { transform: translateX(-5px); }
  40%, 80% { transform: translateX(5px); }
}

/* Декоративные элементы */
.decorative-corner {
  position: absolute;
  width: 100px;
  height: 100px;
  
  &-tl {
    top: 0;
    left: 0;
    border-top: 2px solid #00dbde;
    border-left: 2px solid #00dbde;
    border-radius: 12px 0 0 0;
  }
  
  &-br {
    bottom: 0;
    right: 0;
    border-bottom: 2px solid #fc00ff;
    border-right: 2px solid #fc00ff;
    border-radius: 0 0 12px 0;
  }
}

/* Адаптивность */
@media (max-width: 768px) {
  .lobby-container {
    padding: 1.5rem;
    margin: 1rem;
    
    h2 {
      font-size: 1.8rem;
    }
  }
  
  .mode-indicator {
    flex-direction: column;
    gap: 0.5rem;
    padding: 1rem;
    
    .mode-icon {
      font-size: 2rem;
    }
    
    .mode-title {
      font-size: 1.2rem;
    }
  }
  
  .input-group {
    flex-direction: column;
    gap: 1rem;
    
    button {
      width: 100%;
    }
  }
  
  .option-card {
    padding: 1.5rem;
    
    h3 {
      font-size: 1.3rem;
    }
  }
}

--- Файл: D:\Chess\src\app\features\classic-chess\components\lobby\lobby.component.ts ---

import { ActivatedRoute, Router } from '@angular/router';
import { MultiplayerService } from '../../../../shared/chess-core/services/multiplayer.service';
import { Component } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'app-classic-lobby',
  standalone: true,
  imports: [CommonModule, FormsModule],
  templateUrl: './lobby.component.html',
  styleUrls: ['./lobby.component.scss']
})
export class LobbyComponent {
  gameId: string = '';
  isLoading = false;
  errorMessage: string | null = null;
  currentMode: any;

  chessModes = [
    {
      path: 'classic',
      title: 'Classic Chess',
      icon: '♔',
      description: 'Traditional 8x8 chess'
    },
    {
      path: '5d',
      title: '5D Chess',
      icon: '🌀',
      description: 'Multidimensional chess'
    },
    {
      path: 'dnd',
      title: 'D&D Chess',
      icon: '⚔️',
      description: 'Fantasy RPG chess'
    }
  ];

  constructor(
    private route: ActivatedRoute,
    private router: Router,
    private multiplayer: MultiplayerService
  ) {}

  ngOnInit(): void {
    // Получаем тип игры из параметров маршрута
    const gameType = this.route.snapshot.data['gameType'] || 'classic';
    this.currentMode = this.chessModes.find(m => m.path === gameType) || this.chessModes[0];
  }

  createGame() {
    this.isLoading = true;
    const gameType = this.route.snapshot.params['gameType'] || 'classic';
    
    this.multiplayer.createGame(gameType).then(id => {
      this.router.navigate(['/chess/game', id]);
    }).catch(error => {
      this.errorMessage = 'Failed to create game: ' + error.message;
    }).finally(() => {
      this.isLoading = false;
    });
  }
  
  joinGame() {
    if (!this.gameId) {
      this.errorMessage = 'Please enter a game ID';
      return;
    }
    
    this.isLoading = true;
    const parts = this.gameId.split('-');
    
    if (parts.length < 2 || !['classic', '5d', 'dnd'].includes(parts[0])) {
      this.errorMessage = 'Invalid game ID format';
      this.isLoading = false;
      return;
    }
    
    this.router.navigate(['/chess/game', this.gameId]);
  }
}

--- Файл: D:\Chess\src\app\features\classic-chess\services\classic-game.service.ts ---

import { Injectable } from '@angular/core';
import { BaseGameService } from '../../../shared/chess-core/services/base-game.service';
import { GameState } from '../../../shared/chess-core/models/game-state.model';
import { ChessPiece, Pawn, Rook, Knight, Bishop, Queen, King } from '../../../shared/chess-core/models/chess-piece.model';

@Injectable({
  providedIn: 'root'
})
export class ClassicGameService extends BaseGameService {
  getState(): GameState {
    return this.state;
  }

  setState(state: GameState): void {
    if (state.pieces) {
      state.pieces = state.pieces.map(piece => this.createPieceInstance(piece));
    }
    this.state = state;
  }

  createPieceInstance(pieceData: any): ChessPiece {
    const position = { x: pieceData.position.x, y: pieceData.position.y };
    const color = pieceData.color;
    const hasMoved = pieceData.hasMoved || false;

    switch (pieceData.type) {
      case 'pawn': return new Pawn(position, color, hasMoved);
      case 'rook': return new Rook(position, color, hasMoved);
      case 'knight': return new Knight(position, color, hasMoved);
      case 'bishop': return new Bishop(position, color, hasMoved);
      case 'queen': return new Queen(position, color, hasMoved);
      case 'king': return new King(position, color, hasMoved);
      default: throw new Error(`Unknown piece type: ${pieceData.type}`);
    }
  }
}

--- Файл: D:\Chess\src\app\features\dnd-chess\dnd-chess.module.ts ---

import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterModule } from '@angular/router';

@NgModule({
  imports: [
    CommonModule,
    RouterModule.forChild([
      { 
        path: '', 
        loadComponent: () => import('./components/lobby/lobby.component')
          .then(m => m.LobbyComponent) 
      },
      { 
        path: 'game/:id', 
        loadComponent: () => import('./components/game/dnd-game.component')
          .then(m => m.DndGameComponent)
      }
    ])
  ]
})
export class DndChessModule { }

--- Файл: D:\Chess\src\app\features\dnd-chess\dnd-chess.routes.ts ---



--- Файл: D:\Chess\src\app\features\dnd-chess\components\game\dnd-game.component.html ---

<div class="chessboard-container" [class.classic-mode]="chessType === 'classic'"
                                [class.dnd-mode]="chessType === 'dnd'"
                                [class.five-d-mode]="chessType === '5d'">
  <div class="game-info">
    Ход: {{ gameService.getState().currentPlayer === 'white' ? 'Белые' : 'Чёрные' }}
  </div>
  <app-chessboard [state]="gameService.getState()"></app-chessboard>
  <div class="game-id">ID: {{ gameId }}</div>
  <div class="chat-panel-container">
    <app-chat [gameId]="gameId"></app-chat>
  </div>
</div>

--- Файл: D:\Chess\src\app\features\dnd-chess\components\game\dnd-game.component.scss ---

.game {
  background-color: white;
  border-radius: 8px;
  padding: 2rem;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
  width: 100%;
  max-width: 800px;
  text-align: center;

  h1 {
    color: #333;
    margin-bottom: 1rem;
  }

  p {
    font-size: 1.2rem;
    margin-bottom: 2rem;
    color: #555;
  }
}
.game-screen {
    display: flex;
    min-height: 100vh;
  }
  
  .main-content {
    flex-grow: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 20px;
  }
  
  .side-panel-container {
    width: 280px;
    padding: 20px;
  }
  
  .chat-panel-container {
    width: 300px;
    border-left: 1px solid rgba(255, 255, 255, 0.1);
  }
  
  @media (max-width: 1200px) {
    .side-panel-container,
    .chat-panel-container {
      width: 250px;
    }
  }
  
  @media (max-width: 992px) {
    .game-screen {
      flex-direction: column;
    }
    
    .side-panel-container,
    .chat-panel-container {
      width: 100%;
      max-width: 500px;
      margin: 0 auto;
    }
    
    .chat-panel-container {
      border-left: none;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }
  }

--- Файл: D:\Chess\src\app\features\dnd-chess\components\game\dnd-game.component.ts ---

import { Component, OnInit, OnDestroy } from '@angular/core';
import { ActivatedRoute, Router } from '@angular/router';
import { GameService } from '../../../../shared/chess-core/services/game.service';
import { MultiplayerService } from '../../../../shared/chess-core/services/multiplayer.service';
import { ChessboardComponent } from '../../../../shared/ui/chessboard/chessboard.component';
import { CommonModule } from '@angular/common';
import { createInitialGameState } from '../../../../shared/chess-core/models/game-state.model';
import { ChatComponent } from "../../../../shared/ui/chat/chat.component";
import { ClassicGameService } from '../../services/dnd-game.service';

@Component({
  selector: 'app-classic-game',
  templateUrl: './dnd-game.component.html',
  styleUrls: ['./dnd-game.component.scss'],
  standalone: true,
  imports: [ChessboardComponent, CommonModule, ChatComponent]
})
export class DndGameComponent implements OnInit, OnDestroy {
  gameId: string = '';
  chessType: string = 'classic';

  constructor(
    private route: ActivatedRoute,
    private router: Router,
    public gameService: GameService,
    private multiplayer: MultiplayerService
  ) {}

  ngOnInit(): void {
    this.gameId = this.route.snapshot.params['id'];
    
    // Извлекаем тип игры из ID (первые символы до дефиса)
    const gameType = this.gameId.split('-')[0] as 'classic' | '5d' | 'dnd';
    
    if (!['classic', '5d', 'dnd'].includes(gameType)) {
        this.router.navigate(['/chess/classic']);
        return;
    }
    
    this.chessType = gameType;
    
    // Инициализируем состояние игры с правильным типом
    this.gameService.setState(createInitialGameState(gameType));
    
    if (this.gameId) {
        this.multiplayer.joinGame(this.gameId);
    }
  }

  ngOnDestroy(): void {
    this.multiplayer.ngOnDestroy();
  }

  onLeaveGame(): void {
    this.router.navigate(['/chess', this.chessType]);
  }
}

--- Файл: D:\Chess\src\app\features\dnd-chess\components\lobby\lobby.component.html ---

<!-- Файл: src/app/components/lobby/lobby.component.html -->
<div class="lobby-container">
  <div class="decorative-corner decorative-corner-tl"></div>
  <div class="decorative-corner decorative-corner-br"></div>
  
  <div class="mode-indicator" *ngIf="currentMode">
    <div class="mode-icon">{{currentMode.icon}}</div>
    <div class="mode-title">{{currentMode.title}}</div>
  </div>

  <h2>Create or Join Game</h2>
  
  <div class="game-options">
    <div class="option-card">
      <h3>Create New Game</h3>
      <button (click)="createGame()" [disabled]="isLoading">
        {{ isLoading ? 'Creating...' : 'Create Game' }}
      </button>
    </div>

    <div class="option-card">
      <h3>Join Existing Game</h3>
      <div class="input-group">
        <input [(ngModel)]="gameId" placeholder="Enter Game ID">
        <button (click)="joinGame()" [disabled]="isLoading || !gameId">
          {{ isLoading ? 'Joining...' : 'Join Game' }}
        </button>
      </div>
    </div>
  </div>

  <div *ngIf="errorMessage" class="error-message">
    {{ errorMessage }}
  </div>
</div>

--- Файл: D:\Chess\src\app\features\dnd-chess\components\lobby\lobby.component.scss ---

/* Файл: src/app/components/lobby/lobby.component.scss */

.lobby-container {
  max-width: 800px;
  margin: 2rem auto;
  background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
  border-radius: 16px;
  padding: 2.5rem;
  box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
  text-align: center;
  border: 1px solid rgba(255, 255, 255, 0.1);
  position: relative;
  overflow: hidden;
  
  &::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 4px;
    background: linear-gradient(90deg, #00dbde 0%, #fc00ff 100%);
  }

  h2 {
    color: #fff;
    margin-bottom: 2rem;
    font-size: 2.2rem;
    font-weight: 700;
    text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    position: relative;
    z-index: 2;
  }

  .game-options {
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
    margin-bottom: 2rem;
  }
  .mode-indicator {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 12px;
    margin-bottom: 2rem;
    padding: 1rem;
    background: rgba(74, 107, 218, 0.1);
    border-radius: 12px;
    border: 1px solid rgba(74, 107, 218, 0.2);
    animation: fadeIn 0.3s ease-out;

    .mode-icon {
      font-size: 2rem;
      color: var(--primary);
    }

    .mode-title {
      font-size: 1.25rem;
      font-weight: 600;
      color: var(--primary);
    }
  }

  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(-10px); }
    to { opacity: 1; transform: translateY(0); }
  }
  .option-card {
    background: rgb(0, 0, 0);
    border-radius: var(--border-radius);
    padding: 1.5rem;
    box-shadow: 0 5px 15px rgba(0,0,0,0.05);
    border: 1px solid rgba(0,0,0,0.05);
    transition: var(--transition);

    &:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 25px rgba(0,0,0,0.1);
    }

    h3 {
      color: var(--primary-color);
      margin-bottom: 1rem;
    }

    .input-group {
      display: flex;
      gap: 0.5rem;
      margin-top: 1rem;

      input {
        flex: 1;
        padding: 0.75rem 1rem;
        border: 1px solid #ddd;
        border-radius: var(--border-radius);
        font-size: 1rem;
        transition: var(--transition);

        &:focus {
          outline: none;
          border-color: var(--secondary-color);
          box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
        }
      }

      button {
        padding: 0.75rem 1.5rem;
        background: var(--secondary-color);
        color: white;
        border: none;
        border-radius: var(--border-radius);
        cursor: pointer;
        font-size: 1rem;
        transition: var(--transition);

        &:hover {
          background: adjust-color(#3498db, $lightness: -10%);
          transform: translateY(-2px);
        }

        &:disabled {
          background: #bdc3c7;
          cursor: not-allowed;
          transform: none;
        }
      }
    }
  }

  .error-message {
    color: var(--danger-color);
    margin-top: 1rem;
    padding: 0.75rem;
    background: rgba(231, 76, 60, 0.1);
    border-radius: var(--border-radius);
  }
}

@media (max-width: 768px) {
  .lobby-container {
    padding: 1.5rem;

    h2 {
      font-size: 1.5rem;
    }

    .option-card {
      padding: 1rem;

      .input-group {
        flex-direction: column;

        button {
          width: 100%;
        }
      }
    }
  }
}
.mode-indicator {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 12px;
  margin-bottom: 2rem;
  padding: 1rem;
  background: rgba(74, 107, 218, 0.1);
  border-radius: 12px;
  border: 1px solid rgba(74, 107, 218, 0.2);
  animation: fadeIn 0.3s ease-out;

  .mode-icon {
    font-size: 2rem;
    color: var(--primary);
  }

  .mode-title {
    font-size: 1.25rem;
    font-weight: 600;
    color: var(--primary);
  }
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(-10px); }
  to { opacity: 1; transform: translateY(0); }
}
/* Файл: src/app/components/lobby/lobby.component.scss */

.lobby-container {
  max-width: 800px;
  margin: 2rem auto;
  background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
  border-radius: 16px;
  padding: 2.5rem;
  box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
  text-align: center;
  border: 1px solid rgba(255, 255, 255, 0.1);
  position: relative;
  overflow: hidden;
  
  &::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 4px;
    background: linear-gradient(90deg, #00dbde 0%, #fc00ff 100%);
  }

  h2 {
    color: #fff;
    margin-bottom: 2rem;
    font-size: 2.2rem;
    font-weight: 700;
    text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    position: relative;
    z-index: 2;
  }
}

.mode-indicator {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 16px;
  margin-bottom: 2.5rem;
  padding: 1.25rem;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 12px;
  border: 1px solid rgba(255, 255, 255, 0.1);
  backdrop-filter: blur(10px);
  animation: fadeIn 0.5s ease-out;
  position: relative;
  z-index: 2;

  .mode-icon {
    font-size: 2.5rem;
    color: #fff;
    text-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
  }

  .mode-title {
    font-size: 1.5rem;
    font-weight: 600;
    color: #fff;
    letter-spacing: 1px;
  }
}

.game-options {
  display: grid;
  grid-template-columns: 1fr;
  gap: 2rem;
  margin-bottom: 2rem;
}

.option-card {
  background: rgba(255, 255, 255, 0.05);
  border-radius: 14px;
  padding: 2rem;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
  border: 1px solid rgba(255, 255, 255, 0.1);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  backdrop-filter: blur(10px);
  position: relative;
  overflow: hidden;
  
  &:hover {
    transform: translateY(-5px);
    box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3);
    border-color: rgba(255, 255, 255, 0.2);
  }

  &::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: radial-gradient(circle at 20% 50%, rgba(100, 115, 255, 0.1) 0%, transparent 50%);
    z-index: -1;
  }

  h3 {
    color: #fff;
    margin-bottom: 1.5rem;
    font-size: 1.5rem;
    font-weight: 600;
  }

  button {
    padding: 0.9rem 2rem;
    background: linear-gradient(90deg, #00dbde 0%, #fc00ff 100%);
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 1.1rem;
    font-weight: 600;
    transition: all 0.3s ease;
    box-shadow: 0 4px 15px rgba(0, 219, 222, 0.3);
    position: relative;
    overflow: hidden;
    
    &:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(0, 219, 222, 0.4);
    }
    
    &:active:not(:disabled) {
      transform: translateY(0);
    }
    
    &:disabled {
      background: linear-gradient(90deg, #6c757d 0%, #495057 100%);
      cursor: not-allowed;
      opacity: 0.7;
    }
    
    &::after {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: all 0.5s ease;
    }
    
    &:hover:not(:disabled)::after {
      left: 100%;
    }
  }
}

.input-group {
  display: flex;
  gap: 1rem;
  margin-top: 1.5rem;
  
  input {
    flex: 1;
    padding: 0.9rem 1.5rem;
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 8px;
    font-size: 1rem;
    color: #fff;
    transition: all 0.3s ease;
    
    &::placeholder {
      color: rgba(255, 255, 255, 0.5);
    }
    
    &:focus {
      outline: none;
      border-color: #00dbde;
      box-shadow: 0 0 0 3px rgba(0, 219, 222, 0.2);
      background: rgba(255, 255, 255, 0.15);
    }
  }
}

.error-message {
  color: #ff6b6b;
  margin-top: 1.5rem;
  padding: 1rem;
  background: rgba(255, 107, 107, 0.1);
  border-radius: 8px;
  border: 1px solid rgba(255, 107, 107, 0.3);
  animation: shake 0.5s ease;
}

/* Анимации */
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(-20px); }
  to { opacity: 1; transform: translateY(0); }
}

@keyframes shake {
  0%, 100% { transform: translateX(0); }
  20%, 60% { transform: translateX(-5px); }
  40%, 80% { transform: translateX(5px); }
}

/* Декоративные элементы */
.decorative-corner {
  position: absolute;
  width: 100px;
  height: 100px;
  
  &-tl {
    top: 0;
    left: 0;
    border-top: 2px solid #00dbde;
    border-left: 2px solid #00dbde;
    border-radius: 12px 0 0 0;
  }
  
  &-br {
    bottom: 0;
    right: 0;
    border-bottom: 2px solid #fc00ff;
    border-right: 2px solid #fc00ff;
    border-radius: 0 0 12px 0;
  }
}

/* Адаптивность */
@media (max-width: 768px) {
  .lobby-container {
    padding: 1.5rem;
    margin: 1rem;
    
    h2 {
      font-size: 1.8rem;
    }
  }
  
  .mode-indicator {
    flex-direction: column;
    gap: 0.5rem;
    padding: 1rem;
    
    .mode-icon {
      font-size: 2rem;
    }
    
    .mode-title {
      font-size: 1.2rem;
    }
  }
  
  .input-group {
    flex-direction: column;
    gap: 1rem;
    
    button {
      width: 100%;
    }
  }
  
  .option-card {
    padding: 1.5rem;
    
    h3 {
      font-size: 1.3rem;
    }
  }
}

--- Файл: D:\Chess\src\app\features\dnd-chess\components\lobby\lobby.component.ts ---

import { ActivatedRoute, Router } from '@angular/router';
import { MultiplayerService } from '../../../../shared/chess-core/services/multiplayer.service';
import { Component } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'app-classic-lobby',
  templateUrl: './lobby.component.html',
  styleUrls: ['./lobby.component.scss'],
  standalone: true,
  imports: [FormsModule, CommonModule]
})
export class LobbyComponent {
  gameId: string = '';
  isLoading = false;
  errorMessage: string | null = null;
  currentMode: any;

  chessModes = [
    {
      path: 'classic',
      title: 'Classic Chess',
      icon: '♔',
      description: 'Traditional 8x8 chess'
    },
    {
      path: '5d',
      title: '5D Chess',
      icon: '🌀',
      description: 'Multidimensional chess'
    },
    {
      path: 'dnd',
      title: 'D&D Chess',
      icon: '⚔️',
      description: 'Fantasy RPG chess'
    }
  ];

  constructor(
    private route: ActivatedRoute,
    private router: Router,
    private multiplayer: MultiplayerService
  ) {}

  ngOnInit(): void {
    // Получаем тип игры из параметров маршрута
    const gameType = this.route.snapshot.data['gameType'] || 'classic';
    this.currentMode = this.chessModes.find(m => m.path === gameType) || this.chessModes[0];
  }

  createGame() {
    this.isLoading = true;
    const gameType = this.route.snapshot.params['gameType'] || 'classic';
    
    this.multiplayer.createGame(gameType).then(id => {
      this.router.navigate(['/chess/game', id]);
    }).catch(error => {
      this.errorMessage = 'Failed to create game: ' + error.message;
    }).finally(() => {
      this.isLoading = false;
    });
  }
  
  joinGame() {
    if (!this.gameId) {
      this.errorMessage = 'Please enter a game ID';
      return;
    }
    
    this.isLoading = true;
    const parts = this.gameId.split('-');
    
    if (parts.length < 2 || !['classic', '5d', 'dnd'].includes(parts[0])) {
      this.errorMessage = 'Invalid game ID format';
      this.isLoading = false;
      return;
    }
    
    this.router.navigate(['/chess/game', this.gameId]);
  }
}

--- Файл: D:\Chess\src\app\features\dnd-chess\services\dnd-game.service.ts ---

import { Injectable } from '@angular/core';
import { BaseGameService } from '../../../shared/chess-core/services/base-game.service';
import { GameState } from '../../../shared/chess-core/models/game-state.model';
import { ChessPiece, Pawn, Rook, Knight, Bishop, Queen, King } from '../../../shared/chess-core/models/chess-piece.model';

@Injectable({
  providedIn: 'root'
})
export class ClassicGameService extends BaseGameService {
  getState(): GameState {
    return this.state;
  }

  setState(state: GameState): void {
    if (state.pieces) {
      state.pieces = state.pieces.map(piece => this.createPieceInstance(piece));
    }
    this.state = state;
  }

  createPieceInstance(pieceData: any): ChessPiece {
    const position = { x: pieceData.position.x, y: pieceData.position.y };
    const color = pieceData.color;
    const hasMoved = pieceData.hasMoved || false;

    switch (pieceData.type) {
      case 'pawn': return new Pawn(position, color, hasMoved);
      case 'rook': return new Rook(position, color, hasMoved);
      case 'knight': return new Knight(position, color, hasMoved);
      case 'bishop': return new Bishop(position, color, hasMoved);
      case 'queen': return new Queen(position, color, hasMoved);
      case 'king': return new King(position, color, hasMoved);
      default: throw new Error(`Unknown piece type: ${pieceData.type}`);
    }
  }
}

--- Файл: D:\Chess\src\app\features\five-d-chess\five-d-chess.module.ts ---

import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterModule } from '@angular/router';

@NgModule({
  imports: [
    CommonModule,
    RouterModule.forChild([
      { 
        path: '', 
        loadComponent: () => import('./components/lobby/lobby.component')
          .then(m => m.LobbyComponent) 
      },
      { 
        path: 'game/:id', 
        loadComponent: () => import('./components/game/five-d-game.component')
          .then(m => m.FiveDGameComponent)
      }
    ])
  ]
})
export class FiveDChessModule { }

--- Файл: D:\Chess\src\app\features\five-d-chess\five-d-chess.routes.ts ---



--- Файл: D:\Chess\src\app\features\five-d-chess\components\game\five-d-game.component.html ---

<div class="chessboard-container" [class.classic-mode]="chessType === 'classic'"
                                [class.dnd-mode]="chessType === 'dnd'"
                                [class.five-d-mode]="chessType === '5d'">
  <div class="game-info">
    Ход: {{ gameService.getState().currentPlayer === 'white' ? 'Белые' : 'Чёрные' }}
  </div>
  <app-chessboard [state]="gameService.getState()"></app-chessboard>
  <div class="game-id">ID: {{ gameId }}</div>
  <div class="chat-panel-container">
    <app-chat [gameId]="gameId"></app-chat>
  </div>
</div>

--- Файл: D:\Chess\src\app\features\five-d-chess\components\game\five-d-game.component.scss ---

.game {
  background-color: white;
  border-radius: 8px;
  padding: 2rem;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
  width: 100%;
  max-width: 800px;
  text-align: center;

  h1 {
    color: #333;
    margin-bottom: 1rem;
  }

  p {
    font-size: 1.2rem;
    margin-bottom: 2rem;
    color: #555;
  }
}
.game-screen {
    display: flex;
    min-height: 100vh;
  }
  
  .main-content {
    flex-grow: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 20px;
  }
  
  .side-panel-container {
    width: 280px;
    padding: 20px;
  }
  
  .chat-panel-container {
    width: 300px;
    border-left: 1px solid rgba(255, 255, 255, 0.1);
  }
  
  @media (max-width: 1200px) {
    .side-panel-container,
    .chat-panel-container {
      width: 250px;
    }
  }
  
  @media (max-width: 992px) {
    .game-screen {
      flex-direction: column;
    }
    
    .side-panel-container,
    .chat-panel-container {
      width: 100%;
      max-width: 500px;
      margin: 0 auto;
    }
    
    .chat-panel-container {
      border-left: none;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }
  }

--- Файл: D:\Chess\src\app\features\five-d-chess\components\game\five-d-game.component.ts ---

import { Component, OnInit, OnDestroy } from '@angular/core';
import { ActivatedRoute, Router } from '@angular/router';
import { GameService } from '../../../../shared/chess-core/services/game.service';
import { MultiplayerService } from '../../../../shared/chess-core/services/multiplayer.service';
import { ChessboardComponent } from '../../../../shared/ui/chessboard/chessboard.component';
import { CommonModule } from '@angular/common';
import { createInitialGameState } from '../../../../shared/chess-core/models/game-state.model';
import { ChatComponent } from "../../../../shared/ui/chat/chat.component";
import { ClassicGameService } from '../../services/five-d-game.service';

@Component({
  selector: 'app-classic-game',
  templateUrl: './five-d-game.component.html',
  styleUrls: ['./five-d-game.component.scss'],
  standalone: true,
  imports: [ChessboardComponent, CommonModule, ChatComponent]
})
export class FiveDGameComponent implements OnInit, OnDestroy {
  gameId: string = '';
  chessType: string = 'classic';

  constructor(
    private route: ActivatedRoute,
    private router: Router,
    public gameService: GameService,
    private multiplayer: MultiplayerService
  ) {}

  ngOnInit(): void {
    this.gameId = this.route.snapshot.params['id'];
    
    // Извлекаем тип игры из ID (первые символы до дефиса)
    const gameType = this.gameId.split('-')[0] as 'classic' | '5d' | 'dnd';
    
    if (!['classic', '5d', 'dnd'].includes(gameType)) {
        this.router.navigate(['/chess/classic']);
        return;
    }
    
    this.chessType = gameType;
    
    // Инициализируем состояние игры с правильным типом
    this.gameService.setState(createInitialGameState(gameType));
    
    if (this.gameId) {
        this.multiplayer.joinGame(this.gameId);
    }
  }

  ngOnDestroy(): void {
    this.multiplayer.ngOnDestroy();
  }

  onLeaveGame(): void {
    this.router.navigate(['/chess', this.chessType]);
  }
}

--- Файл: D:\Chess\src\app\features\five-d-chess\components\lobby\lobby.component.html ---

<!-- Файл: src/app/components/lobby/lobby.component.html -->
<div class="lobby-container">
  <div class="decorative-corner decorative-corner-tl"></div>
  <div class="decorative-corner decorative-corner-br"></div>
  
  <div class="mode-indicator" *ngIf="currentMode">
    <div class="mode-icon">{{currentMode.icon}}</div>
    <div class="mode-title">{{currentMode.title}}</div>
  </div>

  <h2>Create or Join Game</h2>
  
  <div class="game-options">
    <div class="option-card">
      <h3>Create New Game</h3>
      <button (click)="createGame()" [disabled]="isLoading">
        {{ isLoading ? 'Creating...' : 'Create Game' }}
      </button>
    </div>

    <div class="option-card">
      <h3>Join Existing Game</h3>
      <div class="input-group">
        <input [(ngModel)]="gameId" placeholder="Enter Game ID">
        <button (click)="joinGame()" [disabled]="isLoading || !gameId">
          {{ isLoading ? 'Joining...' : 'Join Game' }}
        </button>
      </div>
    </div>
  </div>

  <div *ngIf="errorMessage" class="error-message">
    {{ errorMessage }}
  </div>
</div>

--- Файл: D:\Chess\src\app\features\five-d-chess\components\lobby\lobby.component.scss ---

/* Файл: src/app/components/lobby/lobby.component.scss */

.lobby-container {
  max-width: 800px;
  margin: 2rem auto;
  background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
  border-radius: 16px;
  padding: 2.5rem;
  box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
  text-align: center;
  border: 1px solid rgba(255, 255, 255, 0.1);
  position: relative;
  overflow: hidden;
  
  &::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 4px;
    background: linear-gradient(90deg, #00dbde 0%, #fc00ff 100%);
  }

  h2 {
    color: #fff;
    margin-bottom: 2rem;
    font-size: 2.2rem;
    font-weight: 700;
    text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    position: relative;
    z-index: 2;
  }

  .game-options {
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
    margin-bottom: 2rem;
  }
  .mode-indicator {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 12px;
    margin-bottom: 2rem;
    padding: 1rem;
    background: rgba(74, 107, 218, 0.1);
    border-radius: 12px;
    border: 1px solid rgba(74, 107, 218, 0.2);
    animation: fadeIn 0.3s ease-out;

    .mode-icon {
      font-size: 2rem;
      color: var(--primary);
    }

    .mode-title {
      font-size: 1.25rem;
      font-weight: 600;
      color: var(--primary);
    }
  }

  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(-10px); }
    to { opacity: 1; transform: translateY(0); }
  }
  .option-card {
    background: rgb(0, 0, 0);
    border-radius: var(--border-radius);
    padding: 1.5rem;
    box-shadow: 0 5px 15px rgba(0,0,0,0.05);
    border: 1px solid rgba(0,0,0,0.05);
    transition: var(--transition);

    &:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 25px rgba(0,0,0,0.1);
    }

    h3 {
      color: var(--primary-color);
      margin-bottom: 1rem;
    }

    .input-group {
      display: flex;
      gap: 0.5rem;
      margin-top: 1rem;

      input {
        flex: 1;
        padding: 0.75rem 1rem;
        border: 1px solid #ddd;
        border-radius: var(--border-radius);
        font-size: 1rem;
        transition: var(--transition);

        &:focus {
          outline: none;
          border-color: var(--secondary-color);
          box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
        }
      }

      button {
        padding: 0.75rem 1.5rem;
        background: var(--secondary-color);
        color: white;
        border: none;
        border-radius: var(--border-radius);
        cursor: pointer;
        font-size: 1rem;
        transition: var(--transition);

        &:hover {
          background: adjust-color(#3498db, $lightness: -10%);
          transform: translateY(-2px);
        }

        &:disabled {
          background: #bdc3c7;
          cursor: not-allowed;
          transform: none;
        }
      }
    }
  }

  .error-message {
    color: var(--danger-color);
    margin-top: 1rem;
    padding: 0.75rem;
    background: rgba(231, 76, 60, 0.1);
    border-radius: var(--border-radius);
  }
}

@media (max-width: 768px) {
  .lobby-container {
    padding: 1.5rem;

    h2 {
      font-size: 1.5rem;
    }

    .option-card {
      padding: 1rem;

      .input-group {
        flex-direction: column;

        button {
          width: 100%;
        }
      }
    }
  }
}
.mode-indicator {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 12px;
  margin-bottom: 2rem;
  padding: 1rem;
  background: rgba(74, 107, 218, 0.1);
  border-radius: 12px;
  border: 1px solid rgba(74, 107, 218, 0.2);
  animation: fadeIn 0.3s ease-out;

  .mode-icon {
    font-size: 2rem;
    color: var(--primary);
  }

  .mode-title {
    font-size: 1.25rem;
    font-weight: 600;
    color: var(--primary);
  }
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(-10px); }
  to { opacity: 1; transform: translateY(0); }
}
/* Файл: src/app/components/lobby/lobby.component.scss */

.lobby-container {
  max-width: 800px;
  margin: 2rem auto;
  background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
  border-radius: 16px;
  padding: 2.5rem;
  box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
  text-align: center;
  border: 1px solid rgba(255, 255, 255, 0.1);
  position: relative;
  overflow: hidden;
  
  &::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 4px;
    background: linear-gradient(90deg, #00dbde 0%, #fc00ff 100%);
  }

  h2 {
    color: #fff;
    margin-bottom: 2rem;
    font-size: 2.2rem;
    font-weight: 700;
    text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    position: relative;
    z-index: 2;
  }
}

.mode-indicator {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 16px;
  margin-bottom: 2.5rem;
  padding: 1.25rem;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 12px;
  border: 1px solid rgba(255, 255, 255, 0.1);
  backdrop-filter: blur(10px);
  animation: fadeIn 0.5s ease-out;
  position: relative;
  z-index: 2;

  .mode-icon {
    font-size: 2.5rem;
    color: #fff;
    text-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
  }

  .mode-title {
    font-size: 1.5rem;
    font-weight: 600;
    color: #fff;
    letter-spacing: 1px;
  }
}

.game-options {
  display: grid;
  grid-template-columns: 1fr;
  gap: 2rem;
  margin-bottom: 2rem;
}

.option-card {
  background: rgba(255, 255, 255, 0.05);
  border-radius: 14px;
  padding: 2rem;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
  border: 1px solid rgba(255, 255, 255, 0.1);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  backdrop-filter: blur(10px);
  position: relative;
  overflow: hidden;
  
  &:hover {
    transform: translateY(-5px);
    box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3);
    border-color: rgba(255, 255, 255, 0.2);
  }

  &::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: radial-gradient(circle at 20% 50%, rgba(100, 115, 255, 0.1) 0%, transparent 50%);
    z-index: -1;
  }

  h3 {
    color: #fff;
    margin-bottom: 1.5rem;
    font-size: 1.5rem;
    font-weight: 600;
  }

  button {
    padding: 0.9rem 2rem;
    background: linear-gradient(90deg, #00dbde 0%, #fc00ff 100%);
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 1.1rem;
    font-weight: 600;
    transition: all 0.3s ease;
    box-shadow: 0 4px 15px rgba(0, 219, 222, 0.3);
    position: relative;
    overflow: hidden;
    
    &:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(0, 219, 222, 0.4);
    }
    
    &:active:not(:disabled) {
      transform: translateY(0);
    }
    
    &:disabled {
      background: linear-gradient(90deg, #6c757d 0%, #495057 100%);
      cursor: not-allowed;
      opacity: 0.7;
    }
    
    &::after {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: all 0.5s ease;
    }
    
    &:hover:not(:disabled)::after {
      left: 100%;
    }
  }
}

.input-group {
  display: flex;
  gap: 1rem;
  margin-top: 1.5rem;
  
  input {
    flex: 1;
    padding: 0.9rem 1.5rem;
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 8px;
    font-size: 1rem;
    color: #fff;
    transition: all 0.3s ease;
    
    &::placeholder {
      color: rgba(255, 255, 255, 0.5);
    }
    
    &:focus {
      outline: none;
      border-color: #00dbde;
      box-shadow: 0 0 0 3px rgba(0, 219, 222, 0.2);
      background: rgba(255, 255, 255, 0.15);
    }
  }
}

.error-message {
  color: #ff6b6b;
  margin-top: 1.5rem;
  padding: 1rem;
  background: rgba(255, 107, 107, 0.1);
  border-radius: 8px;
  border: 1px solid rgba(255, 107, 107, 0.3);
  animation: shake 0.5s ease;
}

/* Анимации */
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(-20px); }
  to { opacity: 1; transform: translateY(0); }
}

@keyframes shake {
  0%, 100% { transform: translateX(0); }
  20%, 60% { transform: translateX(-5px); }
  40%, 80% { transform: translateX(5px); }
}

/* Декоративные элементы */
.decorative-corner {
  position: absolute;
  width: 100px;
  height: 100px;
  
  &-tl {
    top: 0;
    left: 0;
    border-top: 2px solid #00dbde;
    border-left: 2px solid #00dbde;
    border-radius: 12px 0 0 0;
  }
  
  &-br {
    bottom: 0;
    right: 0;
    border-bottom: 2px solid #fc00ff;
    border-right: 2px solid #fc00ff;
    border-radius: 0 0 12px 0;
  }
}

/* Адаптивность */
@media (max-width: 768px) {
  .lobby-container {
    padding: 1.5rem;
    margin: 1rem;
    
    h2 {
      font-size: 1.8rem;
    }
  }
  
  .mode-indicator {
    flex-direction: column;
    gap: 0.5rem;
    padding: 1rem;
    
    .mode-icon {
      font-size: 2rem;
    }
    
    .mode-title {
      font-size: 1.2rem;
    }
  }
  
  .input-group {
    flex-direction: column;
    gap: 1rem;
    
    button {
      width: 100%;
    }
  }
  
  .option-card {
    padding: 1.5rem;
    
    h3 {
      font-size: 1.3rem;
    }
  }
}

--- Файл: D:\Chess\src\app\features\five-d-chess\components\lobby\lobby.component.ts ---

import { ActivatedRoute, Router } from '@angular/router';
import { MultiplayerService } from '../../../../shared/chess-core/services/multiplayer.service';
import { Component } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'app-classic-lobby',
  templateUrl: './lobby.component.html',
  styleUrls: ['./lobby.component.scss'],
  standalone: true,
  imports: [FormsModule, CommonModule]
})
export class LobbyComponent {
  gameId: string = '';
  isLoading = false;
  errorMessage: string | null = null;
  currentMode: any;

  chessModes = [
    {
      path: 'classic',
      title: 'Classic Chess',
      icon: '♔',
      description: 'Traditional 8x8 chess'
    },
    {
      path: '5d',
      title: '5D Chess',
      icon: '🌀',
      description: 'Multidimensional chess'
    },
    {
      path: 'dnd',
      title: 'D&D Chess',
      icon: '⚔️',
      description: 'Fantasy RPG chess'
    }
  ];

  constructor(
    private route: ActivatedRoute,
    private router: Router,
    private multiplayer: MultiplayerService
  ) {}

  ngOnInit(): void {
    // Получаем тип игры из параметров маршрута
    const gameType = this.route.snapshot.data['gameType'] || 'classic';
    this.currentMode = this.chessModes.find(m => m.path === gameType) || this.chessModes[0];
  }

  createGame() {
    this.isLoading = true;
    const gameType = this.route.snapshot.params['gameType'] || 'classic';
    
    this.multiplayer.createGame(gameType).then(id => {
      this.router.navigate(['/chess/game', id]);
    }).catch(error => {
      this.errorMessage = 'Failed to create game: ' + error.message;
    }).finally(() => {
      this.isLoading = false;
    });
  }
  
  joinGame() {
    if (!this.gameId) {
      this.errorMessage = 'Please enter a game ID';
      return;
    }
    
    this.isLoading = true;
    const parts = this.gameId.split('-');
    
    if (parts.length < 2 || !['classic', '5d', 'dnd'].includes(parts[0])) {
      this.errorMessage = 'Invalid game ID format';
      this.isLoading = false;
      return;
    }
    
    this.router.navigate(['/chess/game', this.gameId]);
  }
}

--- Файл: D:\Chess\src\app\features\five-d-chess\models\five-d-piece.model.ts ---



--- Файл: D:\Chess\src\app\features\five-d-chess\services\five-d-game.service.ts ---

import { Injectable } from '@angular/core';
import { BaseGameService } from '../../../shared/chess-core/services/base-game.service';
import { GameState } from '../../../shared/chess-core/models/game-state.model';
import { ChessPiece, Pawn, Rook, Knight, Bishop, Queen, King } from '../../../shared/chess-core/models/chess-piece.model';

@Injectable({
  providedIn: 'root'
})
export class ClassicGameService extends BaseGameService {
  getState(): GameState {
    return this.state;
  }

  setState(state: GameState): void {
    if (state.pieces) {
      state.pieces = state.pieces.map(piece => this.createPieceInstance(piece));
    }
    this.state = state;
  }

  createPieceInstance(pieceData: any): ChessPiece {
    const position = { x: pieceData.position.x, y: pieceData.position.y };
    const color = pieceData.color;
    const hasMoved = pieceData.hasMoved || false;

    switch (pieceData.type) {
      case 'pawn': return new Pawn(position, color, hasMoved);
      case 'rook': return new Rook(position, color, hasMoved);
      case 'knight': return new Knight(position, color, hasMoved);
      case 'bishop': return new Bishop(position, color, hasMoved);
      case 'queen': return new Queen(position, color, hasMoved);
      case 'king': return new King(position, color, hasMoved);
      default: throw new Error(`Unknown piece type: ${pieceData.type}`);
    }
  }
}

--- Файл: D:\Chess\src\app\shared\shared.module.ts ---

import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';

@NgModule({
  imports: [
    CommonModule,
    FormsModule
  ],
  exports: [
    CommonModule,
    FormsModule
  ]
})
export class SharedModule { }

--- Файл: D:\Chess\src\app\shared\chess-core\models\chess-piece.model.ts ---

import { GameState } from './game-state.model';

export type PieceType = 'pawn' | 'rook' | 'knight' | 'bishop' | 'queen' | 'king';
export type PieceColor = 'white' | 'black';

export interface Position {
  x: number;
  y: number;
}

export abstract class ChessPiece {
  health: number = 100;
  abilityCharges: number = 3;
  passiveCooldown: number = 0;
  maxHealth: number = 100;
  
  constructor(
    public type: PieceType,
    public position: Position,
    public color: PieceColor,
    public hasMoved: boolean = false
  ) {}

  abstract canMove(to: Position, gameState: GameState): boolean;

  move(to: Position): void {
    this.position = to;
    this.hasMoved = true;
    this.passiveCooldown = Math.max(0, this.passiveCooldown - 1);
  }

  useAbility(): void {
    if (this.abilityCharges > 0) {
      this.abilityCharges--;
    }
  }

  canUsePassive(): boolean {
    return this.passiveCooldown === 0;
  }

  usePassive(): void {
    this.passiveCooldown = 3;
  }

  takeDamage(amount: number): void {
    this.health = Math.max(0, this.health - amount);
  }

  heal(amount: number): void {
    this.health = Math.min(this.maxHealth, this.health + amount);
  }

  getAbilityDescription(): string {
    return 'Basic Attack: Deal 20 damage to target piece (3 charges per round)';
  }

  getPassiveDescription(): string {
    return 'Phase Walk: Move through any piece (once every 3 turns)';
  }

  protected isPathClear(to: Position, gameState: GameState): boolean {
    const dx = Math.sign(to.x - this.position.x);
    const dy = Math.sign(to.y - this.position.y);

    let x = this.position.x + dx;
    let y = this.position.y + dy;

    while (x !== to.x || y !== to.y) {
      if (gameState.pieces.some(p => p.position.x === x && p.position.y === y)) {
        return false;
      }
      x += dx;
      y += dy;
    }

    return true;
  }

  toJSON() {
    return {
      type: this.type,
      position: this.position,
      color: this.color,
      hasMoved: this.hasMoved,
      health: this.health,
      abilityCharges: this.abilityCharges,
      passiveCooldown: this.passiveCooldown,
      maxHealth: this.maxHealth
    };
  }
}

export class Pawn extends ChessPiece {
  constructor(position: Position, color: PieceColor, hasMoved: boolean = false) {
    super('pawn', position, color, hasMoved);
    this.maxHealth = 80;
  }

  canMove(to: Position, gameState: GameState): boolean {
    const direction = this.color === 'white' ? 1 : -1;
    const startRow = this.color === 'white' ? 1 : 6;

    // Standard move
    if (to.x === this.position.x && to.y === this.position.y + direction) {
      return !gameState.pieces.some(p => p.position.x === to.x && p.position.y === to.y);
    }

    // Initial double move
    if (!this.hasMoved && to.x === this.position.x && to.y === this.position.y + 2 * direction && this.position.y === startRow) {
      const intermediatePos = { x: to.x, y: this.position.y + direction };
      return !gameState.pieces.some(p => 
        (p.position.x === to.x && p.position.y === to.y) ||
        (p.position.x === intermediatePos.x && p.position.y === intermediatePos.y)
      );
    }

    // Capture
    if (Math.abs(to.x - this.position.x) === 1 && to.y === this.position.y + direction) {
      const targetPiece = gameState.pieces.find(p => 
        p.position.x === to.x && p.position.y === to.y
      );
      return targetPiece ? targetPiece.color !== this.color : false;
    }

    return false;
  }
}

export class Rook extends ChessPiece {
  constructor(position: Position, color: PieceColor, hasMoved: boolean = false) {
    super('rook', position, color, hasMoved);
    this.maxHealth = 120;
  }

  canMove(to: Position, gameState: GameState): boolean {
    if (to.x !== this.position.x && to.y !== this.position.y) return false;
    if (!this.isPathClear(to, gameState)) return false;

    const targetPiece = gameState.pieces.find(p => 
      p.position.x === to.x && p.position.y === to.y
    );
    
    return !targetPiece || targetPiece.color !== this.color;
  }
}

export class Knight extends ChessPiece {
  constructor(position: Position, color: PieceColor, hasMoved: boolean = false) {
    super('knight', position, color, hasMoved);
    this.maxHealth = 90;
  }

  canMove(to: Position, gameState: GameState): boolean {
    const dx = Math.abs(to.x - this.position.x);
    const dy = Math.abs(to.y - this.position.y);
    
    if (!((dx === 1 && dy === 2) || (dx === 2 && dy === 1))) return false;
    
    const targetPiece = gameState.pieces.find(p => 
      p.position.x === to.x && p.position.y === to.y
    );
    
    return !targetPiece || targetPiece.color !== this.color;
  }
}

export class Bishop extends ChessPiece {
  constructor(position: Position, color: PieceColor, hasMoved: boolean = false) {
    super('bishop', position, color, hasMoved);
    this.maxHealth = 95;
  }

  canMove(to: Position, gameState: GameState): boolean {
    if (Math.abs(to.x - this.position.x) !== Math.abs(to.y - this.position.y)) {
      return false;
    }

    if (!this.isPathClear(to, gameState)) return false;

    const targetPiece = gameState.pieces.find(p => 
      p.position.x === to.x && p.position.y === to.y
    );
    
    return !targetPiece || targetPiece.color !== this.color;
  }
}

export class Queen extends ChessPiece {
  constructor(position: Position, color: PieceColor, hasMoved: boolean = false) {
    super('queen', position, color, hasMoved);
    this.maxHealth = 110;
  }

  canMove(to: Position, gameState: GameState): boolean {
    const isRookMove = (to.x === this.position.x || to.y === this.position.y);
    const isBishopMove = (Math.abs(to.x - this.position.x) === Math.abs(to.y - this.position.y));
    
    if (!isRookMove && !isBishopMove) return false;

    if (!this.isPathClear(to, gameState)) return false;

    const targetPiece = gameState.pieces.find(p => 
      p.position.x === to.x && p.position.y === to.y
    );
    
    return !targetPiece || targetPiece.color !== this.color;
  }
}

export class King extends ChessPiece {
  constructor(position: Position, color: PieceColor, hasMoved: boolean = false) {
    super('king', position, color, hasMoved);
    this.maxHealth = 150;
  }

  canMove(to: Position, gameState: GameState): boolean {
    const dx = Math.abs(to.x - this.position.x);
    const dy = Math.abs(to.y - this.position.y);
    
    if (dx > 1 || dy > 1) return false;
    
    const targetPiece = gameState.pieces.find(p => 
      p.position.x === to.x && p.position.y === to.y
    );
    
    return !targetPiece || targetPiece.color !== this.color;
  }
}

--- Файл: D:\Chess\src\app\shared\chess-core\models\dnd-chess-piece.model.ts ---

import { ChessPiece, PieceType, PieceColor, Position } from './chess-piece.model';
import { GameState } from './game-state.model';

export abstract class DndChessPiece extends ChessPiece {
  abilityDamage: number = 20;
  passiveCooldownDuration: number = 3;

  constructor(
    type: PieceType,
    position: Position,
    color: PieceColor,
    hasMoved: boolean = false
  ) {
    super(type, position, color, hasMoved);
  }

  canMove(to: Position, gameState: GameState): boolean {
    if (this.canUsePassive()) {
      return true; // Can move through pieces when passive is available
    }
    return super.isPathClear(to, gameState);
  }

  override getAbilityDescription(): string {
    return `${this.type} Attack: Deal ${this.abilityDamage} damage to target (${this.abilityCharges}/3 charges)`;
  }

  override getPassiveDescription(): string {
    return `Phase Walk: Move through pieces (ready in ${this.passiveCooldown} turns)`;
  }
}

export class DndPawn extends DndChessPiece {
  constructor(position: Position, color: PieceColor, hasMoved: boolean = false) {
    super('pawn', position, color, hasMoved);
    this.maxHealth = 100;
    this.abilityDamage = 15;
  }

  override canMove(to: Position, gameState: GameState): boolean {
    if (this.canUsePassive()) return true;

    const direction = this.color === 'white' ? 1 : -1;
    const startRow = this.color === 'white' ? 1 : 6;

    // Standard move
    if (to.x === this.position.x && to.y === this.position.y + direction) {
      return !gameState.pieces.some(p => p.position.x === to.x && p.position.y === to.y);
    }

    // Initial double move
    if (!this.hasMoved && to.x === this.position.x && to.y === this.position.y + 2 * direction && this.position.y === startRow) {
      const intermediatePos = { x: to.x, y: this.position.y + direction };
      return !gameState.pieces.some(p => 
        (p.position.x === to.x && p.position.y === to.y) ||
        (p.position.x === intermediatePos.x && p.position.y === intermediatePos.y)
      );
    }

    // Capture
    if (Math.abs(to.x - this.position.x) === 1 && to.y === this.position.y + direction) {
      const targetPiece = gameState.pieces.find(p => 
        p.position.x === to.x && p.position.y === to.y
      );
      return targetPiece ? targetPiece.color !== this.color : false;
    }

    return false;
  }
}

export class DndRook extends DndChessPiece {
  constructor(position: Position, color: PieceColor, hasMoved: boolean = false) {
    super('rook', position, color, hasMoved);
    this.maxHealth = 150;
    this.abilityDamage = 25;
  }

  override canMove(to: Position, gameState: GameState): boolean {
    if (this.canUsePassive()) return true;
    if (to.x !== this.position.x && to.y !== this.position.y) return false;
    if (!this.isPathClear(to, gameState)) return false;

    const targetPiece = gameState.pieces.find(p => 
      p.position.x === to.x && p.position.y === to.y
    );
    
    return !targetPiece || targetPiece.color !== this.color;
  }
}

export class DndKnight extends DndChessPiece {
  constructor(position: Position, color: PieceColor, hasMoved: boolean = false) {
    super('knight', position, color, hasMoved);
    this.maxHealth = 120;
    this.abilityDamage = 30;
  }

  override canMove(to: Position, gameState: GameState): boolean {
    if (this.canUsePassive()) return true;
    
    const dx = Math.abs(to.x - this.position.x);
    const dy = Math.abs(to.y - this.position.y);
    
    if (!((dx === 1 && dy === 2) || (dx === 2 && dy === 1))) return false;
    
    const targetPiece = gameState.pieces.find(p => 
      p.position.x === to.x && p.position.y === to.y
    );
    
    return !targetPiece || targetPiece.color !== this.color;
  }
}

export class DndBishop extends DndChessPiece {
  constructor(position: Position, color: PieceColor, hasMoved: boolean = false) {
    super('bishop', position, color, hasMoved);
    this.maxHealth = 130;
    this.abilityDamage = 20;
  }

  override canMove(to: Position, gameState: GameState): boolean {
    if (this.canUsePassive()) return true;
    if (Math.abs(to.x - this.position.x) !== Math.abs(to.y - this.position.y)) {
      return false;
    }

    if (!this.isPathClear(to, gameState)) return false;

    const targetPiece = gameState.pieces.find(p => 
      p.position.x === to.x && p.position.y === to.y
    );
    
    return !targetPiece || targetPiece.color !== this.color;
  }
}

export class DndQueen extends DndChessPiece {
  constructor(position: Position, color: PieceColor, hasMoved: boolean = false) {
    super('queen', position, color, hasMoved);
    this.maxHealth = 140;
    this.abilityDamage = 35;
  }

  override canMove(to: Position, gameState: GameState): boolean {
    if (this.canUsePassive()) return true;
    
    const isRookMove = (to.x === this.position.x || to.y === this.position.y);
    const isBishopMove = (Math.abs(to.x - this.position.x) === Math.abs(to.y - this.position.y));
    
    if (!isRookMove && !isBishopMove) return false;

    if (!this.isPathClear(to, gameState)) return false;

    const targetPiece = gameState.pieces.find(p => 
      p.position.x === to.x && p.position.y === to.y
    );
    
    return !targetPiece || targetPiece.color !== this.color;
  }
}

export class DndKing extends DndChessPiece {
  constructor(position: Position, color: PieceColor, hasMoved: boolean = false) {
    super('king', position, color, hasMoved);
    this.maxHealth = 200;
    this.abilityDamage = 15;
  }

  override canMove(to: Position, gameState: GameState): boolean {
    if (this.canUsePassive()) return true;
    
    const dx = Math.abs(to.x - this.position.x);
    const dy = Math.abs(to.y - this.position.y);
    
    if (dx > 1 || dy > 1) return false;
    
    const targetPiece = gameState.pieces.find(p => 
      p.position.x === to.x && p.position.y === to.y
    );
    
    return !targetPiece || targetPiece.color !== this.color;
  }
}

--- Файл: D:\Chess\src\app\shared\chess-core\models\game-state.model.ts ---

import { Bishop, ChessPiece, King, Knight, Pawn, Queen, Rook } from './chess-piece.model';
import { DndBishop, DndChessPiece, DndKing, DndKnight, DndPawn, DndQueen, DndRook } from './dnd-chess-piece.model';

export interface GameState {
    id: string;
    currentPlayer: 'white' | 'black';
    pieces: ChessPiece[];
    gameType: 'classic' | '5d' | 'dnd';
    whiteDeviceId?: string;  // ID устройства белого игрока
    blackDeviceId?: string;  // ID устройства черного игрока
    currentUserColor?: 'white' | 'black' | null;
    turnNumber: number;
    isCheck?: boolean;
    isCheckmate?: boolean;
    isStalemate?: boolean;
  }
export function createInitialGameState(gameType: 'classic' | '5d' | 'dnd' = 'classic'): GameState {
  const pieces: (ChessPiece | DndChessPiece)[] = [];

  // White pieces
  if (gameType === 'dnd') {
    pieces.push(new DndRook({ x: 0, y: 0 }, 'white'));
    pieces.push(new DndKnight({ x: 1, y: 0 }, 'white'));
    pieces.push(new DndBishop({ x: 2, y: 0 }, 'white'));
    pieces.push(new DndQueen({ x: 3, y: 0 }, 'white'));
    pieces.push(new DndKing({ x: 4, y: 0 }, 'white'));
    pieces.push(new DndBishop({ x: 5, y: 0 }, 'white'));
    pieces.push(new DndKnight({ x: 6, y: 0 }, 'white'));
    pieces.push(new DndRook({ x: 7, y: 0 }, 'white'));
    for (let i = 0; i < 8; i++) {
      pieces.push(new DndPawn({ x: i, y: 1 }, 'white'));
    }

    // Black pieces
    pieces.push(new DndRook({ x: 0, y: 7 }, 'black'));
    pieces.push(new DndKnight({ x: 1, y: 7 }, 'black'));
    pieces.push(new DndBishop({ x: 2, y: 7 }, 'black'));
    pieces.push(new DndQueen({ x: 3, y: 7 }, 'black'));
    pieces.push(new DndKing({ x: 4, y: 7 }, 'black'));
    pieces.push(new DndBishop({ x: 5, y: 7 }, 'black'));
    pieces.push(new DndKnight({ x: 6, y: 7 }, 'black'));
    pieces.push(new DndRook({ x: 7, y: 7 }, 'black'));
    for (let i = 0; i < 8; i++) {
      pieces.push(new DndPawn({ x: i, y: 6 }, 'black'));
    }
  } else {
    pieces.push(new Rook({ x: 0, y: 0 }, 'white'));
    pieces.push(new Knight({ x: 1, y: 0 }, 'white'));
    pieces.push(new Bishop({ x: 2, y: 0 }, 'white'));
    pieces.push(new Queen({ x: 3, y: 0 }, 'white'));
    pieces.push(new King({ x: 4, y: 0 }, 'white'));
    pieces.push(new Bishop({ x: 5, y: 0 }, 'white'));
    pieces.push(new Knight({ x: 6, y: 0 }, 'white'));
    pieces.push(new Rook({ x: 7, y: 0 }, 'white'));
    for (let i = 0; i < 8; i++) {
      pieces.push(new Pawn({ x: i, y: 1 }, 'white'));
    }

    // Black pieces
    pieces.push(new Rook({ x: 0, y: 7 }, 'black'));
    pieces.push(new Knight({ x: 1, y: 7 }, 'black'));
    pieces.push(new Bishop({ x: 2, y: 7 }, 'black'));
    pieces.push(new Queen({ x: 3, y: 7 }, 'black'));
    pieces.push(new King({ x: 4, y: 7 }, 'black'));
    pieces.push(new Bishop({ x: 5, y: 7 }, 'black'));
    pieces.push(new Knight({ x: 6, y: 7 }, 'black'));
    pieces.push(new Rook({ x: 7, y: 7 }, 'black'));
    for (let i = 0; i < 8; i++) {
      pieces.push(new Pawn({ x: i, y: 6 }, 'black'));
    }
  }

  return {
    id: '',
    currentPlayer: 'white',
    pieces,
    isCheck: false,
    isCheckmate: false,
    isStalemate: false,
    gameType,
    turnNumber: 1
  };
}

--- Файл: D:\Chess\src\app\shared\chess-core\models\position.model.ts ---

export interface Position {
    x: number; // 0-7 (a-h)
    y: number; // 0-7 (1-8)
  }

--- Файл: D:\Chess\src\app\shared\chess-core\services\base-game.service.ts ---

import { Injectable } from '@angular/core';
import { GameState, createInitialGameState } from '../models/game-state.model';
import { ChessPiece } from '../models/chess-piece.model';

@Injectable({
  providedIn: 'root'
})
export abstract class BaseGameService {
  protected state: GameState = createInitialGameState('classic');

  abstract getState(): GameState;
  abstract setState(state: GameState): void;
  abstract createPieceInstance(pieceData: any): ChessPiece;
}

--- Файл: D:\Chess\src\app\shared\chess-core\services\firebase.service.ts ---

import { Injectable, inject, NgZone } from '@angular/core';
import { GameState } from '../models/game-state.model';
import { Database, ref, set, push, onValue, update, off } from '@angular/fire/database';
import { Observable } from 'rxjs';

@Injectable({ providedIn: 'root' })
export class FirebaseService {
  private db = inject(Database);
  private zone = inject(NgZone);
  private activeListeners: {[gameId: string]: () => void} = {};

  async createGame(state: GameState): Promise<void> {
    if (!state.id) {
        throw new Error('Game state must have an ID');
    }
    
    const gameRef = ref(this.db, `games/${state.id}`);
    await set(gameRef, state);
  }

  getGameState(gameId: string): Observable<GameState> {
    return new Observable(subscriber => {
      this.zone.runOutsideAngular(() => {
        const gameRef = ref(this.db, `games/${gameId}`);
        
        if (this.activeListeners[gameId]) {
          this.activeListeners[gameId]();
        }

        const unsubscribe = onValue(gameRef, (snapshot) => {
          this.zone.run(() => {
            const data = snapshot.val();
            if (data) {
              subscriber.next(data);
            }
          });
        });

        this.activeListeners[gameId] = unsubscribe;

        return () => {
          this.zone.run(() => {
            if (this.activeListeners[gameId]) {
              this.activeListeners[gameId]();
              delete this.activeListeners[gameId];
            }
          });
        };
      });
    });
  }

  async updateGame(state: GameState): Promise<void> {
    return this.zone.runOutsideAngular(async () => {
      const gameRef = ref(this.db, `games/${state.id}`);
      await update(gameRef, state);
    });
  }

  cleanup(gameId: string): void {
    this.zone.run(() => {
      if (this.activeListeners[gameId]) {
        this.activeListeners[gameId]();
        delete this.activeListeners[gameId];
      }
    });
  }
}

--- Файл: D:\Chess\src\app\shared\chess-core\services\game.service.ts ---

import { Injectable } from '@angular/core';
import { GameState, createInitialGameState } from '../models/game-state.model';
import { ChessPiece, PieceType, PieceColor } from '../models/chess-piece.model';
import { Position } from '../models/position.model';
import { Pawn, Rook, Knight, Bishop, Queen, King } from '../models/chess-piece.model';
import { DndBishop, DndKing, DndKnight, DndPawn, DndQueen, DndRook } from '../models/dnd-chess-piece.model';

@Injectable({ providedIn: 'root' })
export class GameService {
  private state: GameState = createInitialGameState();

  getState(): GameState {
    return this.state;
  }

  setState(state: GameState): void {
    if (state.pieces) {
      state.pieces = state.pieces.map(piece => this.createPieceInstance(piece));
    }
    this.state = state;
  }

  createPieceInstance(pieceData: any): ChessPiece {
    const position = { x: pieceData.position.x, y: pieceData.position.y };
    const color = pieceData.color as PieceColor;
    const hasMoved = pieceData.hasMoved || false;
    const gameType = pieceData.gameType || 'classic';

    if (gameType === 'dnd') {
        switch (pieceData.type as PieceType) {
            case 'pawn': return new DndPawn(position, color, hasMoved);
            case 'rook': return new DndRook(position, color, hasMoved);
            case 'knight': return new DndKnight(position, color, hasMoved);
            case 'bishop': return new DndBishop(position, color, hasMoved);
            case 'queen': return new DndQueen(position, color, hasMoved);
            case 'king': return new DndKing(position, color, hasMoved);
            default: throw new Error(`Unknown piece type: ${pieceData.type}`);
        }
    } else {
        switch (pieceData.type as PieceType) {
            case 'pawn': return new Pawn(position, color, hasMoved);
            case 'rook': return new Rook(position, color, hasMoved);
            case 'knight': return new Knight(position, color, hasMoved);
            case 'bishop': return new Bishop(position, color, hasMoved);
            case 'queen': return new Queen(position, color, hasMoved);
            case 'king': return new King(position, color, hasMoved);
            default: throw new Error(`Unknown piece type: ${pieceData.type}`);
        }
    }
  }
  getPiece(position: Position): ChessPiece | null {
    return this.state.pieces.find(
      p => p.position.x === position.x && p.position.y === position.y
    ) || null;
  }
}

--- Файл: D:\Chess\src\app\shared\chess-core\services\multiplayer.service.ts ---

import { Injectable, OnDestroy } from '@angular/core';
import { FirebaseService } from './firebase.service';
import { GameService } from './game.service';
import { createInitialGameState, GameState } from '../models/game-state.model';
import { Position } from '../models/chess-piece.model';
import { Subscription } from 'rxjs';
import { v4 as uuidv4 } from 'uuid';
import { Route, Router } from '@angular/router';


interface MoveOptions {
    isPassive?: boolean;
    isAbility?: boolean;
  }
  

@Injectable({ providedIn: 'root' })
export class MultiplayerService implements OnDestroy {
  private currentGameId: string | null = null;
  private gameSubscription: Subscription | null = null;
  private deviceId = uuidv4(); // Уникальный ID устройства
  private playerColor: 'white' | 'black' | null = null;

  constructor(
    private firebase: FirebaseService,
    private gameService: GameService,
    private router: Router
  ) {}

  async createGame(gameType: 'classic' | '5d' | 'dnd' = 'classic'): Promise<string> {
    const initialState = createInitialGameState(gameType);
    initialState.id = `${gameType}-${Math.random().toString(36).substr(2, 8)}`;
    initialState.whiteDeviceId = this.deviceId;
    this.playerColor = 'white';
    
    await this.firebase.createGame(initialState);
    return initialState.id;
  }
  
  joinGame(gameId: string): void {
    this.currentGameId = gameId;
    
    this.gameSubscription = this.firebase.getGameState(gameId).subscribe({
      next: (state: GameState) => {
        // Определяем цвет игрока
        if (state.whiteDeviceId === this.deviceId) {
          this.playerColor = 'white';
        } else if (!state.blackDeviceId) {
          this.playerColor = 'black';
          const updatedState = {
            ...state,
            blackDeviceId: this.deviceId
          };
          this.firebase.updateGame(updatedState);
        } else if (state.blackDeviceId === this.deviceId) {
          this.playerColor = 'black';
        } else {
          // Игра уже занята двумя игроками
          this.router.navigate(['/chess', gameId.split('-')[0]]);
          return;
        }
        
        this.gameService.setState({
          ...state,
          currentUserColor: this.playerColor
        });
      },
      error: (err) => console.error('Game state error:', err)
    });
  }

  async makeMove(from: Position, to: Position, options: MoveOptions = {}): Promise<boolean> {
    const { isPassive = false, isAbility = false } = options;
    if (!this.currentGameId || !this.playerColor) return false;
    
    const currentState = this.gameService.getState();
    
    // Проверяем, может ли текущий игрок сделать ход
    if (this.playerColor !== currentState.currentPlayer) {
      console.log("Not your turn!");
      return false;
    }
    
    // Получаем фигуру
    const piece = currentState.pieces.find(p => 
      p.position.x === from.x && p.position.y === from.y
    );
    
    if (!piece || piece.color !== currentState.currentPlayer) {
      return false;
    }

    // Проверяем возможность хода
    if (!piece.canMove(to, currentState)) {
      return false;
    }

    // Создаем новое состояние
    const newPieces = currentState.pieces
      .filter(p => !(p.position.x === to.x && p.position.y === to.y))
      .map(p => {
        if (p.position.x === from.x && p.position.y === from.y) {
          const newPiece = this.gameService.createPieceInstance(p);
          newPiece.move(to);
          return newPiece;
        }
        return p;
      });

    const newState: GameState = {
      ...currentState,
      pieces: newPieces,
      currentPlayer: currentState.currentPlayer === 'white' ? 'black' : 'white',
      turnNumber: currentState.turnNumber + (currentState.currentPlayer === 'black' ? 1 : 0)
    };

    try {
      await this.firebase.updateGame(newState);
      return true;
    } catch (error) {
      console.error("Move failed:", error);
      return false;
    }
  }

  ngOnDestroy(): void {
    if (this.gameSubscription) {
      this.gameSubscription.unsubscribe();
    }
  }
  async useAbility(from: Position, target: Position): Promise<boolean> {
    if (!this.currentGameId) return false;
    
    const currentState = this.gameService.getState();
    const piece = currentState.pieces.find(p => 
      p.position.x === from.x && p.position.y === from.y
    );
    
    if (!piece || piece.color !== currentState.currentPlayer || piece.abilityCharges <= 0) {
      return false;
    }

    const targetPiece = currentState.pieces.find(p => 
      p.position.x === target.x && p.position.y === target.y
    );

    if (!targetPiece) return false;

    // Create new state with damage applied
    const newPieces = currentState.pieces.map(p => {
      const newPiece = this.gameService.createPieceInstance(p);
      
      if (p === piece) {
        newPiece.useAbility();
      }
      
      if (p === targetPiece) {
        newPiece.takeDamage((piece as any).abilityDamage || 20);
      }
      
      return newPiece;
    }).filter(p => p.health > 0);

    const newState: GameState = {
      ...currentState,
      pieces: newPieces
    };

    await this.firebase.updateGame(newState);
    return true;
  }

}

--- Файл: D:\Chess\src\app\shared\ui\chat\chat.component.html ---

<div class="chat-container">
    <div class="messages">
      @for (msg of messages; track msg.timestamp) {
        <div class="message" [class.current-user]="msg.senderId === senderId">
          <div class="text">{{msg.text}}</div>
          <div class="time">{{msg.timestamp | date:'shortTime'}}</div>
        </div>
      }
    </div>
    
    <div class="input-area">
      <input 
        [(ngModel)]="newMessage" 
        placeholder="Type your message..." 
        (keyup.enter)="sendMessage()"
      >
      <button (click)="sendMessage()">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor">
          <path d="M22 2L11 13M22 2l-7 20-4-9-9-4 20-7z"></path>
        </svg>
      </button>
    </div>
  </div>

--- Файл: D:\Chess\src\app\shared\ui\chat\chat.component.scss ---

.chat-container {
    width: 300px;
    height: 70vh; /* 80% высоты экрана */
    max-height: 800px; /* Максимальная высота */
    display: flex;
    flex-direction: column;
    background: rgba(30, 30, 30, 0.8);
    border-left: 1px solid rgba(255, 255, 255, 0.1);
    padding: 15px;
    color: white;
    position: fixed;
    right: 75%;
    top: 50%;
    transform: translateY(-50%); /* Центрирование по вертикали */
    box-shadow: -5px 0 15px rgba(0, 0, 0, 0.2);
    border-radius: 8px 0 0 8px;
    
    .messages {
      flex: 1; /* Занимает все доступное пространство */
      overflow-y: auto; /* Включаем прокрутку */
      margin-bottom: 15px;
      padding-right: 8px; /* Чтобы не заезжало под скроллбар */
      
      /* Стили скроллбара */
      &::-webkit-scrollbar {
        width: 6px;
      }
      
      &::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 3px;
      }
      
      &::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.2);
        border-radius: 3px;
      }
  
      .message {
        margin-bottom: 10px;
        padding: 8px;
        border-radius: 8px;
        background: rgba(255, 255, 255, 0.1);
  
        &.current-user {
          background: rgba(74, 107, 218, 0.3);
        }
  
        .text {
          margin-bottom: 4px;
          word-break: break-word; /* Перенос длинных слов */
        }
  
        .time {
          font-size: 0.8em;
          color: rgba(255, 255, 255, 0.6);
          text-align: right;
        }
      }
    }
  
    .input-area {
      display: flex;
      gap: 10px;
      margin-top: auto; /* Прижимаем к низу */
  
      input {
        flex-grow: 1;
        padding: 8px 12px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 20px;
        color: white;
        outline: none;
  
        &:focus {
          border-color: #4a6bda;
        }
      }
  
      button {
        padding: 8px 16px;
        background: #4a6bda;
        color: white;
        border: none;
        border-radius: 20px;
        cursor: pointer;
        transition: background 0.2s;
  
        &:hover {
          background: #3a5bc0;
        }
      }
    }
  }
  
  /* Адаптация для мобильных устройств */
  @media (max-width: 768px) {
    .chat-container {
      width: 100%;
      height: 40vh;
      max-height: none;
      position: fixed;
      bottom: 0;
      top: auto;
      right: 0;
      transform: none;
      border-radius: 8px 8px 0 0;
      border-left: none;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }
  }

--- Файл: D:\Chess\src\app\shared\ui\chat\chat.component.ts ---

import { Component, Input, OnDestroy } from '@angular/core';
import { Database, ref, push, onValue, Unsubscribe } from '@angular/fire/database';
import { CommonModule, DatePipe } from '@angular/common';
import { FormsModule } from '@angular/forms';

@Component({
  selector: 'app-chat',
  standalone: true,
  imports: [CommonModule, FormsModule],
  templateUrl: './chat.component.html',
  styleUrls: ['./chat.component.scss']
})
export class ChatComponent implements OnDestroy {
  @Input() gameId!: string;
  messages: any[] = [];
  newMessage = '';
  senderId = Math.random().toString(36).substring(2, 15); // Изменено на public
  private chatUnsubscribe: Unsubscribe | null = null;

  constructor(private db: Database) {}

  ngOnInit() {
    this.loadMessages();
  }

  ngOnDestroy() {
    if (this.chatUnsubscribe) {
      this.chatUnsubscribe();
    }
  }
  private scrollToBottom() {
    setTimeout(() => {
      const messagesContainer = document.querySelector('.messages');
      if (messagesContainer) {
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
      }
    }, 0);
  }
  
  // Обновите методы loadMessages и sendMessage:
  loadMessages() {
    const chatRef = ref(this.db, `games/${this.gameId}/chat`);
    this.chatUnsubscribe = onValue(chatRef, (snapshot) => {
      const messages = snapshot.val() || {};
      this.messages = Object.values(messages).sort((a: any, b: any) => a.timestamp - b.timestamp);
      this.scrollToBottom(); // Автопрокрутка при загрузке сообщений
    });
  }
  
  async sendMessage() {
    if (!this.newMessage.trim()) return;
  
    const message = {
      senderId: this.senderId,
      text: this.newMessage,
      timestamp: Date.now()
    };
  
    const chatRef = ref(this.db, `games/${this.gameId}/chat`);
    await push(chatRef, message);
    this.newMessage = '';
    this.scrollToBottom(); // Автопрокрутка после отправки
  }
}

--- Файл: D:\Chess\src\app\shared\ui\chessboard\chessboard.component.html ---

<div class="game-screen">
    <!-- Основной контейнер с центрированной доской -->
    <div class="main-content">
      <div class="chessboard-wrapper">
        <div class="game-type-header">
          <h2>{{ getGameTypeDisplayName() }}</h2>
        </div>
        <div class="chessboard-container">
            <div class="chessboard" 
            [class.dnd-mode]="gameType === 'dnd'"
            [class.classic-mode]="gameType === 'classic'"
            [class.five-d-mode]="gameType === '5d'"
            [class.flipped]="isBoardFlipped">
             <div *ngIf="gameType === 'dnd'" class="dnd-decorations">
              <div class="web web-top-left"></div>
              <div class="chandelier chandelier-left"></div>
              <div class="chandelier chandelier-right"></div>
              <div class="pumpkin"></div>
              <div class="point-light point-light-left"></div>
              <div class="point-light point-light-right"></div>
            </div>        
          
          <div *ngFor="let row of [0,1,2,3,4,5,6,7]; let y = index" class="row">
            <div
              *ngFor="let col of [0,1,2,3,4,5,6,7]; let x = index"
              class="cell"
              [class.selected]="selectedPiece?.x === x && selectedPiece?.y === y"
              [class.possible-move]="isPossibleMove({x, y})"
              (click)="handleCellClick({x, y})"
            >
              <span *ngIf="getPieceAt({x, y}) as piece" 
                    [class.white]="piece.color === 'white'"
                    [class.black]="piece.color === 'black'"
                    [class.low-health]="gameType === 'dnd' && piece.health <= 30">
                {{ getPieceSymbol(piece.type) }}
              </span>
              
              <div *ngIf="isPossibleMove({x, y})" class="move-dot"></div>
            </div>
          </div>
        </div>
      </div>
    </div>
  
    <div class="side-panel-container">
        <div class="side-panel" *ngIf="selectedPieceInfo"
             [class.dnd-mode]="gameType === 'dnd'"
             [class.classic-mode]="gameType === 'classic'"
             [class.five-d-mode]="gameType === '5d'">
      <div class="panel-header">
        <h3>{{ getGameTypeDisplayName() }}</h3>
        <span class="piece-icon">{{ getPieceSymbol(selectedPieceInfo.type) }}</span>
        <h3>{{ selectedPieceInfo.type | titlecase }}</h3>
      </div>
      
      <!-- D&D специфичная информация -->
      <div *ngIf="gameType === 'dnd'" class="health-section">
        <div class="health-bar">
          <div class="health-fill" [style.width.%]="(selectedPieceInfo.health / selectedPieceInfo.maxHealth) * 100"></div>
          <span class="health-text">{{ selectedPieceInfo.health }}/{{ selectedPieceInfo.maxHealth }} HP</span>
        </div>
      </div>
  
      <div *ngIf="gameType === 'dnd'" class="move-options">
        <div class="option-buttons">
          <button class="move-option" 
                  [class.active]="selectedMoveType === 'normal'"
                  (click)="selectMoveType('normal')">
            <span class="option-icon">♟</span>
            <span class="option-label">Normal Move</span>
          </button>
          
          <button class="move-option ability-option"
                  [class.active]="selectedMoveType === 'ability'"
                  [class.disabled]="selectedPieceInfo.abilityCharges <= 0"
                  (click)="selectMoveType('ability')">
            <span class="option-icon">⚔️</span>
            <span class="option-label">Attack ({{selectedPieceInfo.abilityCharges}}/3)</span>
          </button>
        </div>
      </div>
    </div>
  </div>

--- Файл: D:\Chess\src\app\shared\ui\chessboard\chessboard.component.scss ---

/* Общие стили для контейнера шахматной доски */
.chessboard-container {
    display: flex;
    justify-content: center;
    gap: 20px;
    padding: 20px;
    max-width: 1200px;
    margin: 0 auto;
    position: relative;
  }
  
  /* Стили для боковой панели информации о фигуре */
  .side-panel {
    position: fixed;
    right: 20px;
    top: 50%;
    transform: translateY(-50%);
    width: 280px;
    padding: 20px;
    border-radius: 12px;
    box-shadow: 0 5px 25px rgba(0,0,0,0.4);
    z-index: 100;
    backdrop-filter: blur(12px);
    transition: all 0.3s ease-out;
    max-height: 80vh;
    overflow-y: auto;
    
    /* Стили для разных режимов */
    &.classic-mode {
      background: rgba(245, 222, 179, 0.92);
      border: 1px solid #d2b48c;
      color: #5D4037;
    }
    
    &.dnd-mode {
      background: rgba(44, 62, 80, 0.92);
      border: 1px solid #8e44ad;
      color: #ecf0f1;
    }
    
    &.five-d-mode {
      background: rgba(25, 42, 86, 0.92);
      border: 1px solid #3498db;
      color: #e1f5fe;
    }
  
    .panel-header {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 20px;
      text-align: center;
      
      .piece-icon {
        font-size: 48px;
        margin: 10px 0;
        line-height: 1;
      }
      
      h3 {
        margin: 5px 0;
        font-size: 1.2rem;
      }
    }
  
    .health-section {
      width: 100%;
      margin: 20px 0;
      
      .health-bar {
        height: 24px;
        border-radius: 12px;
        overflow: hidden;
        position: relative;
        margin-bottom: 8px;
        box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        
        .health-fill {
          height: 100%;
          transition: width 0.4s ease-out;
        }
        
        .health-text {
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          font-size: 13px;
          font-weight: bold;
          text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }
      }
    }
  
    .move-options {
      margin-top: 25px;
      
      .option-buttons {
        display: flex;
        flex-direction: column;
        gap: 12px;
        
        button {
          padding: 10px 15px;
          border: none;
          border-radius: 8px;
          cursor: pointer;
          transition: all 0.25s ease;
          display: flex;
          align-items: center;
          justify-content: center;
          gap: 10px;
          font-size: 15px;
          
          &:hover:not(.disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
          }
          
          &.active {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
          }
          
          &.disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
          }
          
          .option-icon {
            font-size: 20px;
          }
        }
      }
    }
  }
  
  /* Специфичные стили для каждого режима */
  .side-panel.classic-mode {
    .health-bar {
      background: #e6d8b5;
      border: 1px solid #b58863;
      
      .health-fill {
        background: #8B4513;
      }
      
      .health-text {
        color: #5D4037;
      }
    }
    
    button {
      background: #8B4513;
      color: white;
      box-shadow: 0 2px 5px rgba(139, 69, 19, 0.3);
      
      &:hover:not(.disabled) {
        background: #6e3610;
      }
      
      &.active {
        background: #5D4037;
        box-shadow: 0 4px 15px rgba(93, 64, 55, 0.4);
      }
    }
  }
  
  .side-panel.dnd-mode {
    .health-bar {
      background: rgba(0,0,0,0.3);
      border: 1px solid #f1c40f;
      
      .health-fill {
        background: #f1c40f;
      }
      
      .health-text {
        color: white;
      }
    }
    
    button {
      background: #8e44ad;
      color: white;
      box-shadow: 0 2px 5px rgba(142, 68, 173, 0.3);
      
      &:hover:not(.disabled) {
        background: #7d3c98;
      }
      
      &.active {
        background: #6C3483;
        box-shadow: 0 4px 15px rgba(108, 52, 131, 0.5);
      }
      
      &.ability-option {
        background: #e74c3c;
        box-shadow: 0 2px 5px rgba(231, 76, 60, 0.3);
        
        &:hover:not(.disabled) {
          background: #d62c1a;
        }
        
        &.active {
          background: #c0392b;
          box-shadow: 0 4px 15px rgba(192, 57, 43, 0.5);
        }
      }
    }
  }
  
  .side-panel.five-d-mode {
    .health-bar {
      background: rgba(0,0,0,0.3);
      border: 1px solid #2ecc71;
      
      .health-fill {
        background: #2ecc71;
      }
      
      .health-text {
        color: white;
      }
    }
    
    button {
      background: #3498db;
      color: white;
      box-shadow: 0 2px 5px rgba(52, 152, 219, 0.3);
      
      &:hover:not(.disabled) {
        background: #2980b9;
      }
      
      &.active {
        background: #1a5276;
        box-shadow: 0 4px 15px rgba(26, 82, 118, 0.5);
      }
    }
  }
  
  /* Адаптация для разных размеров экрана */
  @media (max-width: 1200px) {
    .side-panel {
      width: 240px;
      right: 15px;
      padding: 15px;
    }
  }
  
  @media (max-width: 992px) {
    .side-panel {
      width: 220px;
      padding: 12px;
      
      .panel-header .piece-icon {
        font-size: 40px;
      }
    }
  }
  
  @media (max-width: 768px) {
    .chessboard-container {
      flex-direction: column;
      align-items: center;
    }
    
    .side-panel {
      position: relative;
      top: auto;
      right: auto;
      transform: none;
      width: 100%;
      max-width: 400px;
      margin: 20px auto 0;
      max-height: none;
    }
  }
  
  @media (max-width: 480px) {
    .side-panel {
      padding: 15px;
      
      .panel-header .piece-icon {
        font-size: 36px;
      }
      
      .health-bar {
        height: 20px;
      }
      
      .move-options .option-buttons button {
        padding: 8px 12px;
        font-size: 14px;
      }
    }
  }
  /* Основной контейнер */
.game-container {
    display: flex;
    justify-content: center;
    gap: 40px;
    padding: 20px;
    max-width: 1400px;
    margin: 0 auto;
    position: relative;
  }
  
  /* Контейнер шахматной доски */
  .chessboard-wrapper {
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  
  /* Боковая панель */
  .side-panel {
    position: sticky;
    top: 50vh;
    transform: translateY(-50%);
    width: 280px;
    height: fit-content;
    padding: 20px;
    border-radius: 12px;
    box-shadow: 0 5px 25px rgba(0,0,0,0.4);
    z-index: 100;
    backdrop-filter: blur(12px);
    align-self: flex-start;
    margin-left: auto;
  }
  
  /* Адаптация для мобильных */
  @media (max-width: 1024px) {
    .game-container {
      flex-direction: column;
      align-items: center;
      gap: 20px;
    }
    
    .side-panel {
      position: relative;
      top: auto;
      transform: none;
      width: 100%;
      max-width: 400px;
      margin: 20px auto 0;
    }
  }
  .game-layout {
    display: flex;
    justify-content: center;
    width: 100%;
    max-width: 1200px;
    margin: 0 auto;
    gap: 30px;
  }
  
  .board-container {
    flex: 0 0 auto;
    /* Фиксированная ширина доски + отступы */
    width: calc(8 * 60px + 30px); /* 8 клеток по 60px + padding */
  }
  
  .side-panel-container {
    flex: 0 0 300px; /* Фиксированная ширина панели */
    position: relative;
  }
  
  .side-panel {
    position: sticky;
    top: 50vh;
    transform: translateY(-50%);
    width: 100%;
    padding: 20px;
    border-radius: 12px;
    box-shadow: 0 5px 25px rgba(0,0,0,0.4);
    z-index: 100;
    backdrop-filter: blur(12px);
  }
  
  /* Адаптация для мобильных */
  @media (max-width: 1024px) {
    .game-layout {
      flex-direction: column;
      align-items: center;
    }
    
    .board-container {
      width: 100%;
      max-width: calc(8 * 60px + 30px);
    }
    
    .side-panel-container {
      width: 100%;
      max-width: 400px;
      margin-top: 20px;
    }
    
    .side-panel {
      position: relative;
      top: auto;
      transform: none;
    }
  }
  .game-screen {
    display: flex;
    min-height: 100vh;
  }
  
  .main-content {
    flex-grow: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 20px;
  }
  
  .chessboard-container {
    /* Центрирование доски */
    margin: 0 auto;
  }
  
  .side-panel-container {
    position: fixed;
    right: 10px;
    top: 0;
    height: 100vh;
    width: 300px;
    padding: 20px;
    box-sizing: border-box;
    display: flex;
    align-items: center;
    z-index: 100;
  }
  
  .side-panel {
    width: 100%;
    max-height: 90vh;
    overflow-y: auto;
    padding: 20px;
    border-radius: 12px 0 0 12px;
    box-shadow: -5px 0 15px rgba(0,0,0,0.2);
    backdrop-filter: blur(10px);
    
    /* Стили для разных режимов */
    &.classic-mode {
      background: rgba(245, 222, 179, 0.95);
      border: 1px solid #d2b48c;
    }
    &.dnd-mode {
      background: rgba(44, 62, 80, 0.95);
      border: 1px solid #8e44ad;
    }
    &.five-d-mode {
      background: rgba(25, 42, 86, 0.95);
      border: 1px solid #3498db;
    }
  }
  
  /* Адаптация для мобильных */
  @media (max-width: 1024px) {
    .side-panel-wrapper {
      position: relative;
      width: 100%;
      height: auto;
      padding: 0;
      margin-top: 20px;
    }
    
    .side-panel {
      border-radius: 12px;
      max-width: 500px;
      margin: 0 auto;
      max-height: none;
    }
    
    .game-screen {
      flex-direction: column;
    }
  }
  .chessboard.flipped {
    transform: rotate(180deg);
    
    .cell span {
      transform: rotate(180deg);
    }
    
    .row {
      flex-direction: row-reverse;
    }
  }

--- Файл: D:\Chess\src\app\shared\ui\chessboard\chessboard.component.ts ---

import { Component, Input, OnChanges, SimpleChanges } from '@angular/core';
import type { GameState } from '../../chess-core/models/game-state.model';
import { Position } from '../../chess-core/models/chess-piece.model';
import { MultiplayerService } from '../../chess-core/services/multiplayer.service';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'app-chessboard',
  templateUrl: './chessboard.component.html',
  styleUrls: ['./chessboard.component.scss'],
  standalone: true,
  imports: [CommonModule]
})
export class ChessboardComponent {
  @Input() gameType: 'classic' | '5d' | 'dnd' = 'classic';
  @Input() state!: GameState;
  selectedPiece: Position | null = null;
  selectedPieceInfo: any = null;
  selectedMoveType: 'normal' | 'ability' | 'passive' = 'normal';
  possibleMoves: Position[] = [];

  constructor(private multiplayer: MultiplayerService) {}

  isBoardFlipped = false;

  ngOnChanges(changes: SimpleChanges): void {
    if (changes['state']) {
      this.gameType = this.state?.gameType || 'classic';
      this.clearSelection();
      
      // Переворачиваем доску для черных
      if (this.state.currentUserColor) {
        this.isBoardFlipped = this.state.currentUserColor === 'black';
      }
    }
  }

  getPieceAt(position: Position): any {
    return this.state.pieces.find(p => 
      p.position.x === position.x && p.position.y === position.y
    );
  }

  getGameTypeDisplayName(): string {
    switch(this.gameType) {
      case '5d': return '5D Chess';
      case 'dnd': return 'D&D Chess';
      default: return 'Classic Chess';
    }
  }

  getGameTypeName(type: string): string {
    const names: Record<string, string> = {
      'classic': 'Classic Chess',
      '5d': '5D Chess',
      'dnd': 'D&D Chess'
    };
    return names[type] || 'Chess';
  }

  getPieceSymbol(type: string): string {
    const symbols: Record<string, string> = {
      pawn: '♟', rook: '♜', knight: '♞',
      bishop: '♝', queen: '♛', king: '♚'
    };
    return symbols[type] || '';
  }

  isPossibleMove(position: Position): boolean {
    return this.possibleMoves.some(move => 
      move.x === position.x && move.y === position.y
    );
  }

  handleCellClick(position: Position): void {
    const piece = this.getPieceAt(position);
    
    if (piece && piece.color === this.state.currentPlayer) {
      this.selectPiece(position);
      return;
    }

    if (this.selectedPiece) {
      this.makeMove(position);
    }
  }

  selectPiece(position: Position): void {
    const piece = this.getPieceAt(position);
    if (!piece || piece.color !== this.state.currentPlayer) return;

    this.selectedPiece = position;
    this.calculatePossibleMoves(position);
    
    this.selectedPieceInfo = {
      type: piece.type,
      color: piece.color,
      ...(this.gameType === 'dnd' && {
        health: piece.health,
        maxHealth: piece.maxHealth,
        abilityDamage: piece['abilityDamage'] || 20,
        abilityCharges: piece.abilityCharges,
        passiveCooldown: piece.passiveCooldown
      })
    };
    this.selectedMoveType = 'normal';
  }

  calculatePossibleMoves(position: Position): void {
    this.possibleMoves = [];
    const piece = this.getPieceAt(position);
    if (!piece) return;

    for (let x = 0; x < 8; x++) {
      for (let y = 0; y < 8; y++) {
        const targetPos = {x, y};
        if (this.gameType === 'dnd' && this.selectedMoveType === 'passive') {
          this.possibleMoves.push(targetPos);
        } else if (piece.canMove(targetPos, this.state)) {
          this.possibleMoves.push(targetPos);
        }
      }
    }
  }

  selectMoveType(type: 'normal' | 'ability' | 'passive'): void {
    if (this.gameType !== 'dnd') return;
    if (type === 'ability' && this.selectedPieceInfo?.abilityCharges <= 0) return;
    if (type === 'passive' && this.selectedPieceInfo?.passiveCooldown > 0) return;
    
    this.selectedMoveType = type;
    this.calculatePossibleMoves(this.selectedPiece!);
  }

  async makeMove(targetPosition: Position): Promise<void> {
    if (!this.selectedPiece || !this.state.currentUserColor) return;
    
    const piece = this.getPieceAt(this.selectedPiece);
    if (!piece || piece.color !== this.state.currentUserColor) return;
  
    let success: boolean;
    
    if (this.gameType === 'dnd') {
      switch (this.selectedMoveType) {
        case 'ability':
          success = await this.multiplayer.useAbility(this.selectedPiece, targetPosition);
          break;
        case 'passive':
          success = await this.multiplayer.makeMove(this.selectedPiece, targetPosition, { isPassive: true });
          break;
        default:
          success = await this.multiplayer.makeMove(this.selectedPiece, targetPosition);
      }
    } else {
      success = await this.multiplayer.makeMove(this.selectedPiece, targetPosition, { isAbility: true });
    }

    if (success) {
      this.clearSelection();
    }
  }

  clearSelection(): void {
    this.selectedPiece = null;
    this.selectedPieceInfo = null;
    this.possibleMoves = [];
    this.selectedMoveType = 'normal';
  }
}


--- Файл: D:\Chess\src\app\shared\ui\game-wrapper\game-wrapper.component.html ---

<p>game-wrapper works!</p>


--- Файл: D:\Chess\src\app\shared\ui\game-wrapper\game-wrapper.component.scss ---



--- Файл: D:\Chess\src\app\shared\ui\game-wrapper\game-wrapper.component.ts ---

import { Component, OnInit } from '@angular/core';
import { ActivatedRoute, Router } from '@angular/router';
import { GameService } from '../../chess-core/services/game.service';
import { MultiplayerService } from '../../chess-core/services/multiplayer.service';
import { createInitialGameState } from '../../chess-core/models/game-state.model';

@Component({
  selector: 'app-game-wrapper',
  templateUrl: './game-wrapper.component.html',
  styleUrls: ['./game-wrapper.component.scss']
})
export class GameWrapperComponent implements OnInit {
  gameId: string = '';
  chessType: string = 'classic';

  constructor(
    private route: ActivatedRoute,
    private router: Router,
    public gameService: GameService,
    private multiplayer: MultiplayerService
  ) {}

  ngOnInit(): void {
    this.gameId = this.route.snapshot.params['id'];
    const gameType = this.gameId.split('-')[0] as 'classic' | '5d' | 'dnd';
    
    if (!['classic', '5d', 'dnd'].includes(gameType)) {
      this.router.navigate(['/chess/classic']);
      return;
    }
    
    this.chessType = gameType;
    this.gameService.setState(createInitialGameState(gameType));
    
    if (this.gameId) {
      this.multiplayer.joinGame(this.gameId);
    }
  }

  onLeaveGame(): void {
    this.router.navigate(['/chess', this.chessType]);
  }
}

